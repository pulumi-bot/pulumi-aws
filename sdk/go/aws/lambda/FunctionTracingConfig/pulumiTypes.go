// *** WARNING: this file was generated by the Pulumi Terraform Bridge (tfgen) Tool. ***
// *** Do not edit by hand unless you're certain you know what you are doing! ***

// nolint: lll
package FunctionTracingConfig

import (
	"context"
	"reflect"

	"github.com/pulumi/pulumi/sdk/go/pulumi"
)

type FunctionTracingConfig struct {
	// Can be either `PassThrough` or `Active`. If PassThrough, Lambda will only trace
	// the request from an upstream service if it contains a tracing header with
	// "sampled=1". If Active, Lambda will respect any tracing header it receives
	// from an upstream service. If no tracing header is received, Lambda will call
	// X-Ray for a tracing decision.
	Mode string `pulumi:"mode"`
}

type FunctionTracingConfigInput interface {
	pulumi.Input

	ToFunctionTracingConfigOutput() FunctionTracingConfigOutput
	ToFunctionTracingConfigOutputWithContext(context.Context) FunctionTracingConfigOutput
}

type FunctionTracingConfigArgs struct {
	// Can be either `PassThrough` or `Active`. If PassThrough, Lambda will only trace
	// the request from an upstream service if it contains a tracing header with
	// "sampled=1". If Active, Lambda will respect any tracing header it receives
	// from an upstream service. If no tracing header is received, Lambda will call
	// X-Ray for a tracing decision.
	Mode pulumi.StringInput `pulumi:"mode"`
}

func (FunctionTracingConfigArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*FunctionTracingConfig)(nil)).Elem()
}

func (i FunctionTracingConfigArgs) ToFunctionTracingConfigOutput() FunctionTracingConfigOutput {
	return i.ToFunctionTracingConfigOutputWithContext(context.Background())
}

func (i FunctionTracingConfigArgs) ToFunctionTracingConfigOutputWithContext(ctx context.Context) FunctionTracingConfigOutput {
	return pulumi.ToOutputWithContext(ctx, i).(FunctionTracingConfigOutput)
}

func (i FunctionTracingConfigArgs) ToFunctionTracingConfigPtrOutput() FunctionTracingConfigPtrOutput {
	return i.ToFunctionTracingConfigPtrOutputWithContext(context.Background())
}

func (i FunctionTracingConfigArgs) ToFunctionTracingConfigPtrOutputWithContext(ctx context.Context) FunctionTracingConfigPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(FunctionTracingConfigOutput).ToFunctionTracingConfigPtrOutputWithContext(ctx)
}

type FunctionTracingConfigPtrInput interface {
	pulumi.Input

	ToFunctionTracingConfigPtrOutput() FunctionTracingConfigPtrOutput
	ToFunctionTracingConfigPtrOutputWithContext(context.Context) FunctionTracingConfigPtrOutput
}

type functionTracingConfigPtrType FunctionTracingConfigArgs

func FunctionTracingConfigPtr(v *FunctionTracingConfigArgs) FunctionTracingConfigPtrInput {	return (*functionTracingConfigPtrType)(v)
}

func (*functionTracingConfigPtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**FunctionTracingConfig)(nil)).Elem()
}

func (i *functionTracingConfigPtrType) ToFunctionTracingConfigPtrOutput() FunctionTracingConfigPtrOutput {
	return i.ToFunctionTracingConfigPtrOutputWithContext(context.Background())
}

func (i *functionTracingConfigPtrType) ToFunctionTracingConfigPtrOutputWithContext(ctx context.Context) FunctionTracingConfigPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(FunctionTracingConfigPtrOutput)
}

type FunctionTracingConfigOutput struct { *pulumi.OutputState }

func (FunctionTracingConfigOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*FunctionTracingConfig)(nil)).Elem()
}

func (o FunctionTracingConfigOutput) ToFunctionTracingConfigOutput() FunctionTracingConfigOutput {
	return o
}

func (o FunctionTracingConfigOutput) ToFunctionTracingConfigOutputWithContext(ctx context.Context) FunctionTracingConfigOutput {
	return o
}

func (o FunctionTracingConfigOutput) ToFunctionTracingConfigPtrOutput() FunctionTracingConfigPtrOutput {
	return o.ToFunctionTracingConfigPtrOutputWithContext(context.Background())
}

func (o FunctionTracingConfigOutput) ToFunctionTracingConfigPtrOutputWithContext(ctx context.Context) FunctionTracingConfigPtrOutput {
	return o.ApplyT(func(v FunctionTracingConfig) *FunctionTracingConfig {
		return &v
	}).(FunctionTracingConfigPtrOutput)
}
// Can be either `PassThrough` or `Active`. If PassThrough, Lambda will only trace
// the request from an upstream service if it contains a tracing header with
// "sampled=1". If Active, Lambda will respect any tracing header it receives
// from an upstream service. If no tracing header is received, Lambda will call
// X-Ray for a tracing decision.
func (o FunctionTracingConfigOutput) Mode() pulumi.StringOutput {
	return o.ApplyT(func (v FunctionTracingConfig) string { return v.Mode }).(pulumi.StringOutput)
}

type FunctionTracingConfigPtrOutput struct { *pulumi.OutputState}

func (FunctionTracingConfigPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**FunctionTracingConfig)(nil)).Elem()
}

func (o FunctionTracingConfigPtrOutput) ToFunctionTracingConfigPtrOutput() FunctionTracingConfigPtrOutput {
	return o
}

func (o FunctionTracingConfigPtrOutput) ToFunctionTracingConfigPtrOutputWithContext(ctx context.Context) FunctionTracingConfigPtrOutput {
	return o
}

func (o FunctionTracingConfigPtrOutput) Elem() FunctionTracingConfigOutput {
	return o.ApplyT(func (v *FunctionTracingConfig) FunctionTracingConfig { return *v }).(FunctionTracingConfigOutput)
}

// Can be either `PassThrough` or `Active`. If PassThrough, Lambda will only trace
// the request from an upstream service if it contains a tracing header with
// "sampled=1". If Active, Lambda will respect any tracing header it receives
// from an upstream service. If no tracing header is received, Lambda will call
// X-Ray for a tracing decision.
func (o FunctionTracingConfigPtrOutput) Mode() pulumi.StringOutput {
	return o.ApplyT(func (v FunctionTracingConfig) string { return v.Mode }).(pulumi.StringOutput)
}

func init() {
	pulumi.RegisterOutputType(FunctionTracingConfigOutput{})
	pulumi.RegisterOutputType(FunctionTracingConfigPtrOutput{})
}
