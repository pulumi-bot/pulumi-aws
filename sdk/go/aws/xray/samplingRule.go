// *** WARNING: this file was generated by the Pulumi Terraform Bridge (tfgen) Tool. ***
// *** Do not edit by hand unless you're certain you know what you are doing! ***

package xray

import (
	"github.com/pkg/errors"
	"github.com/pulumi/pulumi/sdk/go/pulumi"
)

// Creates and manages an AWS XRay Sampling Rule.
//
// > This content is derived from https://github.com/terraform-providers/terraform-provider-aws/blob/master/website/docs/r/xray_sampling_rule.html.markdown.
type SamplingRule struct {
	s *pulumi.ResourceState
}

// NewSamplingRule registers a new resource with the given unique name, arguments, and options.
func NewSamplingRule(ctx *pulumi.Context,
	name string, args *SamplingRuleArgs, opts ...pulumi.ResourceOpt) (*SamplingRule, error) {
	if args == nil || args.FixedRate == nil {
		return nil, errors.New("missing required argument 'FixedRate'")
	}
	if args == nil || args.Host == nil {
		return nil, errors.New("missing required argument 'Host'")
	}
	if args == nil || args.HttpMethod == nil {
		return nil, errors.New("missing required argument 'HttpMethod'")
	}
	if args == nil || args.Priority == nil {
		return nil, errors.New("missing required argument 'Priority'")
	}
	if args == nil || args.ReservoirSize == nil {
		return nil, errors.New("missing required argument 'ReservoirSize'")
	}
	if args == nil || args.ResourceArn == nil {
		return nil, errors.New("missing required argument 'ResourceArn'")
	}
	if args == nil || args.ServiceName == nil {
		return nil, errors.New("missing required argument 'ServiceName'")
	}
	if args == nil || args.ServiceType == nil {
		return nil, errors.New("missing required argument 'ServiceType'")
	}
	if args == nil || args.UrlPath == nil {
		return nil, errors.New("missing required argument 'UrlPath'")
	}
	if args == nil || args.Version == nil {
		return nil, errors.New("missing required argument 'Version'")
	}
	inputs := make(map[string]interface{})
	if args == nil {
		inputs["attributes"] = nil
		inputs["fixedRate"] = nil
		inputs["host"] = nil
		inputs["httpMethod"] = nil
		inputs["priority"] = nil
		inputs["reservoirSize"] = nil
		inputs["resourceArn"] = nil
		inputs["ruleName"] = nil
		inputs["serviceName"] = nil
		inputs["serviceType"] = nil
		inputs["urlPath"] = nil
		inputs["version"] = nil
	} else {
		inputs["attributes"] = args.Attributes
		inputs["fixedRate"] = args.FixedRate
		inputs["host"] = args.Host
		inputs["httpMethod"] = args.HttpMethod
		inputs["priority"] = args.Priority
		inputs["reservoirSize"] = args.ReservoirSize
		inputs["resourceArn"] = args.ResourceArn
		inputs["ruleName"] = args.RuleName
		inputs["serviceName"] = args.ServiceName
		inputs["serviceType"] = args.ServiceType
		inputs["urlPath"] = args.UrlPath
		inputs["version"] = args.Version
	}
	inputs["arn"] = nil
	s, err := ctx.RegisterResource("aws:xray/samplingRule:SamplingRule", name, true, inputs, opts...)
	if err != nil {
		return nil, err
	}
	return &SamplingRule{s: s}, nil
}

// GetSamplingRule gets an existing SamplingRule resource's state with the given name, ID, and optional
// state properties that are used to uniquely qualify the lookup (nil if not required).
func GetSamplingRule(ctx *pulumi.Context,
	name string, id pulumi.ID, state *SamplingRuleState, opts ...pulumi.ResourceOpt) (*SamplingRule, error) {
	inputs := make(map[string]interface{})
	if state != nil {
		inputs["arn"] = state.Arn
		inputs["attributes"] = state.Attributes
		inputs["fixedRate"] = state.FixedRate
		inputs["host"] = state.Host
		inputs["httpMethod"] = state.HttpMethod
		inputs["priority"] = state.Priority
		inputs["reservoirSize"] = state.ReservoirSize
		inputs["resourceArn"] = state.ResourceArn
		inputs["ruleName"] = state.RuleName
		inputs["serviceName"] = state.ServiceName
		inputs["serviceType"] = state.ServiceType
		inputs["urlPath"] = state.UrlPath
		inputs["version"] = state.Version
	}
	s, err := ctx.ReadResource("aws:xray/samplingRule:SamplingRule", name, id, inputs, opts...)
	if err != nil {
		return nil, err
	}
	return &SamplingRule{s: s}, nil
}

// URN is this resource's unique name assigned by Pulumi.
func (r *SamplingRule) URN() pulumi.URNOutput {
	return r.s.URN()
}

// ID is this resource's unique identifier assigned by its provider.
func (r *SamplingRule) ID() pulumi.IDOutput {
	return r.s.ID()
}

// The ARN of the sampling rule.
func (r *SamplingRule) Arn() pulumi.StringOutput {
	return (pulumi.StringOutput)(r.s.State["arn"])
}

// Matches attributes derived from the request.
func (r *SamplingRule) Attributes() pulumi.MapOutput {
	return (pulumi.MapOutput)(r.s.State["attributes"])
}

// The percentage of matching requests to instrument, after the reservoir is exhausted.
func (r *SamplingRule) FixedRate() pulumi.Float64Output {
	return (pulumi.Float64Output)(r.s.State["fixedRate"])
}

// Matches the hostname from a request URL.
func (r *SamplingRule) Host() pulumi.StringOutput {
	return (pulumi.StringOutput)(r.s.State["host"])
}

// Matches the HTTP method of a request.
func (r *SamplingRule) HttpMethod() pulumi.StringOutput {
	return (pulumi.StringOutput)(r.s.State["httpMethod"])
}

// The priority of the sampling rule.
func (r *SamplingRule) Priority() pulumi.IntOutput {
	return (pulumi.IntOutput)(r.s.State["priority"])
}

// A fixed number of matching requests to instrument per second, prior to applying the fixed rate. The reservoir is not used directly by services, but applies to all services using the rule collectively.
func (r *SamplingRule) ReservoirSize() pulumi.IntOutput {
	return (pulumi.IntOutput)(r.s.State["reservoirSize"])
}

// Matches the ARN of the AWS resource on which the service runs.
func (r *SamplingRule) ResourceArn() pulumi.StringOutput {
	return (pulumi.StringOutput)(r.s.State["resourceArn"])
}

// The name of the sampling rule.
func (r *SamplingRule) RuleName() pulumi.StringOutput {
	return (pulumi.StringOutput)(r.s.State["ruleName"])
}

// Matches the `name` that the service uses to identify itself in segments.
func (r *SamplingRule) ServiceName() pulumi.StringOutput {
	return (pulumi.StringOutput)(r.s.State["serviceName"])
}

// Matches the `origin` that the service uses to identify its type in segments.
func (r *SamplingRule) ServiceType() pulumi.StringOutput {
	return (pulumi.StringOutput)(r.s.State["serviceType"])
}

// Matches the path from a request URL.
func (r *SamplingRule) UrlPath() pulumi.StringOutput {
	return (pulumi.StringOutput)(r.s.State["urlPath"])
}

// The version of the sampling rule format (`1` )
func (r *SamplingRule) Version() pulumi.IntOutput {
	return (pulumi.IntOutput)(r.s.State["version"])
}

// Input properties used for looking up and filtering SamplingRule resources.
type SamplingRuleState struct {
	// The ARN of the sampling rule.
	Arn interface{}
	// Matches attributes derived from the request.
	Attributes interface{}
	// The percentage of matching requests to instrument, after the reservoir is exhausted.
	FixedRate interface{}
	// Matches the hostname from a request URL.
	Host interface{}
	// Matches the HTTP method of a request.
	HttpMethod interface{}
	// The priority of the sampling rule.
	Priority interface{}
	// A fixed number of matching requests to instrument per second, prior to applying the fixed rate. The reservoir is not used directly by services, but applies to all services using the rule collectively.
	ReservoirSize interface{}
	// Matches the ARN of the AWS resource on which the service runs.
	ResourceArn interface{}
	// The name of the sampling rule.
	RuleName interface{}
	// Matches the `name` that the service uses to identify itself in segments.
	ServiceName interface{}
	// Matches the `origin` that the service uses to identify its type in segments.
	ServiceType interface{}
	// Matches the path from a request URL.
	UrlPath interface{}
	// The version of the sampling rule format (`1` )
	Version interface{}
}

// The set of arguments for constructing a SamplingRule resource.
type SamplingRuleArgs struct {
	// Matches attributes derived from the request.
	Attributes interface{}
	// The percentage of matching requests to instrument, after the reservoir is exhausted.
	FixedRate interface{}
	// Matches the hostname from a request URL.
	Host interface{}
	// Matches the HTTP method of a request.
	HttpMethod interface{}
	// The priority of the sampling rule.
	Priority interface{}
	// A fixed number of matching requests to instrument per second, prior to applying the fixed rate. The reservoir is not used directly by services, but applies to all services using the rule collectively.
	ReservoirSize interface{}
	// Matches the ARN of the AWS resource on which the service runs.
	ResourceArn interface{}
	// The name of the sampling rule.
	RuleName interface{}
	// Matches the `name` that the service uses to identify itself in segments.
	ServiceName interface{}
	// Matches the `origin` that the service uses to identify its type in segments.
	ServiceType interface{}
	// Matches the path from a request URL.
	UrlPath interface{}
	// The version of the sampling rule format (`1` )
	Version interface{}
}
