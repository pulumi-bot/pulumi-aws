# coding=utf-8
# *** WARNING: this file was generated by the Pulumi Terraform Bridge (tfgen) Tool. ***
# *** Do not edit by hand unless you're certain you know what you are doing! ***

import warnings
import pulumi
import pulumi.runtime
from typing import Any, Dict, List, Mapping, Optional, Tuple, Union
from .. import _utilities, _tables

__all__ = [
    'AmiCopyEbsBlockDeviceArgs',
    'AmiCopyEphemeralBlockDeviceArgs',
    'AmiEbsBlockDeviceArgs',
    'AmiEphemeralBlockDeviceArgs',
    'AmiFromInstanceEbsBlockDeviceArgs',
    'AmiFromInstanceEphemeralBlockDeviceArgs',
    'DefaultNetworkAclEgressArgs',
    'DefaultNetworkAclIngressArgs',
    'DefaultRouteTableRouteArgs',
    'DefaultSecurityGroupEgressArgs',
    'DefaultSecurityGroupIngressArgs',
    'FleetLaunchTemplateConfigArgs',
    'FleetLaunchTemplateConfigLaunchTemplateSpecificationArgs',
    'FleetLaunchTemplateConfigOverrideArgs',
    'FleetOnDemandOptionsArgs',
    'FleetSpotOptionsArgs',
    'FleetTargetCapacitySpecificationArgs',
    'InstanceCreditSpecificationArgs',
    'InstanceEbsBlockDeviceArgs',
    'InstanceEphemeralBlockDeviceArgs',
    'InstanceMetadataOptionsArgs',
    'InstanceNetworkInterfaceArgs',
    'InstanceRootBlockDeviceArgs',
    'LaunchConfigurationEbsBlockDeviceArgs',
    'LaunchConfigurationEphemeralBlockDeviceArgs',
    'LaunchConfigurationRootBlockDeviceArgs',
    'LaunchTemplateBlockDeviceMappingArgs',
    'LaunchTemplateBlockDeviceMappingEbsArgs',
    'LaunchTemplateCapacityReservationSpecificationArgs',
    'LaunchTemplateCapacityReservationSpecificationCapacityReservationTargetArgs',
    'LaunchTemplateCpuOptionsArgs',
    'LaunchTemplateCreditSpecificationArgs',
    'LaunchTemplateElasticGpuSpecificationArgs',
    'LaunchTemplateElasticInferenceAcceleratorArgs',
    'LaunchTemplateHibernationOptionsArgs',
    'LaunchTemplateIamInstanceProfileArgs',
    'LaunchTemplateInstanceMarketOptionsArgs',
    'LaunchTemplateInstanceMarketOptionsSpotOptionsArgs',
    'LaunchTemplateLicenseSpecificationArgs',
    'LaunchTemplateMetadataOptionsArgs',
    'LaunchTemplateMonitoringArgs',
    'LaunchTemplateNetworkInterfaceArgs',
    'LaunchTemplatePlacementArgs',
    'LaunchTemplateTagSpecificationArgs',
    'NetworkAclEgressArgs',
    'NetworkAclIngressArgs',
    'NetworkInterfaceAttachmentArgs',
    'PeeringConnectionOptionsAccepterArgs',
    'PeeringConnectionOptionsRequesterArgs',
    'RouteTableRouteArgs',
    'SecurityGroupEgressArgs',
    'SecurityGroupIngressArgs',
    'SpotFleetRequestLaunchSpecificationArgs',
    'SpotFleetRequestLaunchSpecificationEbsBlockDeviceArgs',
    'SpotFleetRequestLaunchSpecificationEphemeralBlockDeviceArgs',
    'SpotFleetRequestLaunchSpecificationRootBlockDeviceArgs',
    'SpotFleetRequestLaunchTemplateConfigArgs',
    'SpotFleetRequestLaunchTemplateConfigLaunchTemplateSpecificationArgs',
    'SpotFleetRequestLaunchTemplateConfigOverrideArgs',
    'SpotInstanceRequestCreditSpecificationArgs',
    'SpotInstanceRequestEbsBlockDeviceArgs',
    'SpotInstanceRequestEphemeralBlockDeviceArgs',
    'SpotInstanceRequestMetadataOptionsArgs',
    'SpotInstanceRequestNetworkInterfaceArgs',
    'SpotInstanceRequestRootBlockDeviceArgs',
    'TrafficMirrorFilterRuleDestinationPortRangeArgs',
    'TrafficMirrorFilterRuleSourcePortRangeArgs',
    'VpcEndpointDnsEntryArgs',
    'VpcPeeringConnectionAccepterArgs',
    'VpcPeeringConnectionAccepterAccepterArgs',
    'VpcPeeringConnectionAccepterRequesterArgs',
    'VpcPeeringConnectionRequesterArgs',
    'VpnConnectionRouteArgs',
    'VpnConnectionVgwTelemetryArgs',
    'GetCoipPoolFilterArgs',
    'GetCoipPoolsFilterArgs',
    'GetCustomerGatewayFilterArgs',
    'GetInstanceFilterArgs',
    'GetInstanceTypeOfferingFilterArgs',
    'GetInstanceTypeOfferingsFilterArgs',
    'GetInstancesFilterArgs',
    'GetInternetGatewayFilterArgs',
    'GetLaunchTemplateFilterArgs',
    'GetLocalGatewayFilterArgs',
    'GetLocalGatewayRouteTableFilterArgs',
    'GetLocalGatewayRouteTablesFilterArgs',
    'GetLocalGatewayVirtualInterfaceFilterArgs',
    'GetLocalGatewayVirtualInterfaceGroupFilterArgs',
    'GetLocalGatewayVirtualInterfaceGroupsFilterArgs',
    'GetLocalGatewaysFilterArgs',
    'GetNatGatewayFilterArgs',
    'GetNetworkAclsFilterArgs',
    'GetNetworkInterfaceFilterArgs',
    'GetNetworkInterfacesFilterArgs',
    'GetRouteTableFilterArgs',
    'GetRouteTablesFilterArgs',
    'GetSecurityGroupFilterArgs',
    'GetSecurityGroupsFilterArgs',
    'GetSubnetFilterArgs',
    'GetSubnetIdsFilterArgs',
    'GetVpcDhcpOptionsFilterArgs',
    'GetVpcEndpointFilterArgs',
    'GetVpcEndpointServiceFilterArgs',
    'GetVpcFilterArgs',
    'GetVpcPeeringConnectionFilterArgs',
    'GetVpcsFilterArgs',
    'GetVpnGatewayFilterArgs',
]

@pulumi.input_type
class AmiCopyEbsBlockDeviceArgs:
    def __init__(__self__, *,
                 delete_on_termination: Optional[pulumi.Input[bool]] = None,
                 device_name: Optional[pulumi.Input[str]] = None,
                 encrypted: Optional[pulumi.Input[bool]] = None,
                 iops: Optional[pulumi.Input[float]] = None,
                 snapshot_id: Optional[pulumi.Input[str]] = None,
                 volume_size: Optional[pulumi.Input[float]] = None,
                 volume_type: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[bool] delete_on_termination: Boolean controlling whether the EBS volumes created to
               support each created instance will be deleted once that instance is terminated.
        :param pulumi.Input[str] device_name: The path at which the device is exposed to created instances.
        :param pulumi.Input[bool] encrypted: Boolean controlling whether the created EBS volumes will be encrypted. Can't be used with `snapshot_id`.
        :param pulumi.Input[float] iops: Number of I/O operations per second the
               created volumes will support.
        :param pulumi.Input[str] snapshot_id: The id of an EBS snapshot that will be used to initialize the created
               EBS volumes. If set, the `volume_size` attribute must be at least as large as the referenced
               snapshot.
        :param pulumi.Input[float] volume_size: The size of created volumes in GiB.
               If `snapshot_id` is set and `volume_size` is omitted then the volume will have the same size
               as the selected snapshot.
        :param pulumi.Input[str] volume_type: The type of EBS volume to create. Can be one of "standard" (the
               default), "io1" or "gp2".
        """
        pulumi.set(__self__, "deleteOnTermination", delete_on_termination)
        pulumi.set(__self__, "deviceName", device_name)
        pulumi.set(__self__, "encrypted", encrypted)
        pulumi.set(__self__, "iops", iops)
        pulumi.set(__self__, "snapshotId", snapshot_id)
        pulumi.set(__self__, "volumeSize", volume_size)
        pulumi.set(__self__, "volumeType", volume_type)

    @property
    @pulumi.getter(name="deleteOnTermination")
    def delete_on_termination(self) -> Optional[pulumi.Input[bool]]:
        """
        Boolean controlling whether the EBS volumes created to
        support each created instance will be deleted once that instance is terminated.
        """
        ...

    @delete_on_termination.setter
    def delete_on_termination(self, value: Optional[pulumi.Input[bool]]):
        ...

    @property
    @pulumi.getter(name="deviceName")
    def device_name(self) -> Optional[pulumi.Input[str]]:
        """
        The path at which the device is exposed to created instances.
        """
        ...

    @device_name.setter
    def device_name(self, value: Optional[pulumi.Input[str]]):
        ...

    @property
    @pulumi.getter
    def encrypted(self) -> Optional[pulumi.Input[bool]]:
        """
        Boolean controlling whether the created EBS volumes will be encrypted. Can't be used with `snapshot_id`.
        """
        ...

    @encrypted.setter
    def encrypted(self, value: Optional[pulumi.Input[bool]]):
        ...

    @property
    @pulumi.getter
    def iops(self) -> Optional[pulumi.Input[float]]:
        """
        Number of I/O operations per second the
        created volumes will support.
        """
        ...

    @iops.setter
    def iops(self, value: Optional[pulumi.Input[float]]):
        ...

    @property
    @pulumi.getter(name="snapshotId")
    def snapshot_id(self) -> Optional[pulumi.Input[str]]:
        """
        The id of an EBS snapshot that will be used to initialize the created
        EBS volumes. If set, the `volume_size` attribute must be at least as large as the referenced
        snapshot.
        """
        ...

    @snapshot_id.setter
    def snapshot_id(self, value: Optional[pulumi.Input[str]]):
        ...

    @property
    @pulumi.getter(name="volumeSize")
    def volume_size(self) -> Optional[pulumi.Input[float]]:
        """
        The size of created volumes in GiB.
        If `snapshot_id` is set and `volume_size` is omitted then the volume will have the same size
        as the selected snapshot.
        """
        ...

    @volume_size.setter
    def volume_size(self, value: Optional[pulumi.Input[float]]):
        ...

    @property
    @pulumi.getter(name="volumeType")
    def volume_type(self) -> Optional[pulumi.Input[str]]:
        """
        The type of EBS volume to create. Can be one of "standard" (the
        default), "io1" or "gp2".
        """
        ...

    @volume_type.setter
    def volume_type(self, value: Optional[pulumi.Input[str]]):
        ...


@pulumi.input_type
class AmiCopyEphemeralBlockDeviceArgs:
    def __init__(__self__, *,
                 device_name: Optional[pulumi.Input[str]] = None,
                 virtual_name: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] device_name: The path at which the device is exposed to created instances.
        :param pulumi.Input[str] virtual_name: A name for the ephemeral device, of the form "ephemeralN" where
               *N* is a volume number starting from zero.
        """
        pulumi.set(__self__, "deviceName", device_name)
        pulumi.set(__self__, "virtualName", virtual_name)

    @property
    @pulumi.getter(name="deviceName")
    def device_name(self) -> Optional[pulumi.Input[str]]:
        """
        The path at which the device is exposed to created instances.
        """
        ...

    @device_name.setter
    def device_name(self, value: Optional[pulumi.Input[str]]):
        ...

    @property
    @pulumi.getter(name="virtualName")
    def virtual_name(self) -> Optional[pulumi.Input[str]]:
        """
        A name for the ephemeral device, of the form "ephemeralN" where
        *N* is a volume number starting from zero.
        """
        ...

    @virtual_name.setter
    def virtual_name(self, value: Optional[pulumi.Input[str]]):
        ...


@pulumi.input_type
class AmiEbsBlockDeviceArgs:
    def __init__(__self__, *,
                 device_name: pulumi.Input[str],
                 delete_on_termination: Optional[pulumi.Input[bool]] = None,
                 encrypted: Optional[pulumi.Input[bool]] = None,
                 iops: Optional[pulumi.Input[float]] = None,
                 snapshot_id: Optional[pulumi.Input[str]] = None,
                 volume_size: Optional[pulumi.Input[float]] = None,
                 volume_type: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] device_name: The path at which the device is exposed to created instances.
        :param pulumi.Input[bool] delete_on_termination: Boolean controlling whether the EBS volumes created to
               support each created instance will be deleted once that instance is terminated.
        :param pulumi.Input[bool] encrypted: Boolean controlling whether the created EBS volumes will be encrypted. Can't be used with `snapshot_id`.
        :param pulumi.Input[float] iops: Number of I/O operations per second the
               created volumes will support.
        :param pulumi.Input[str] snapshot_id: The id of an EBS snapshot that will be used to initialize the created
               EBS volumes. If set, the `volume_size` attribute must be at least as large as the referenced
               snapshot.
        :param pulumi.Input[float] volume_size: The size of created volumes in GiB.
               If `snapshot_id` is set and `volume_size` is omitted then the volume will have the same size
               as the selected snapshot.
        :param pulumi.Input[str] volume_type: The type of EBS volume to create. Can be one of "standard" (the
               default), "io1" or "gp2".
        """
        pulumi.set(__self__, "deviceName", device_name)
        pulumi.set(__self__, "deleteOnTermination", delete_on_termination)
        pulumi.set(__self__, "encrypted", encrypted)
        pulumi.set(__self__, "iops", iops)
        pulumi.set(__self__, "snapshotId", snapshot_id)
        pulumi.set(__self__, "volumeSize", volume_size)
        pulumi.set(__self__, "volumeType", volume_type)

    @property
    @pulumi.getter(name="deviceName")
    def device_name(self) -> pulumi.Input[str]:
        """
        The path at which the device is exposed to created instances.
        """
        ...

    @device_name.setter
    def device_name(self, value: pulumi.Input[str]):
        ...

    @property
    @pulumi.getter(name="deleteOnTermination")
    def delete_on_termination(self) -> Optional[pulumi.Input[bool]]:
        """
        Boolean controlling whether the EBS volumes created to
        support each created instance will be deleted once that instance is terminated.
        """
        ...

    @delete_on_termination.setter
    def delete_on_termination(self, value: Optional[pulumi.Input[bool]]):
        ...

    @property
    @pulumi.getter
    def encrypted(self) -> Optional[pulumi.Input[bool]]:
        """
        Boolean controlling whether the created EBS volumes will be encrypted. Can't be used with `snapshot_id`.
        """
        ...

    @encrypted.setter
    def encrypted(self, value: Optional[pulumi.Input[bool]]):
        ...

    @property
    @pulumi.getter
    def iops(self) -> Optional[pulumi.Input[float]]:
        """
        Number of I/O operations per second the
        created volumes will support.
        """
        ...

    @iops.setter
    def iops(self, value: Optional[pulumi.Input[float]]):
        ...

    @property
    @pulumi.getter(name="snapshotId")
    def snapshot_id(self) -> Optional[pulumi.Input[str]]:
        """
        The id of an EBS snapshot that will be used to initialize the created
        EBS volumes. If set, the `volume_size` attribute must be at least as large as the referenced
        snapshot.
        """
        ...

    @snapshot_id.setter
    def snapshot_id(self, value: Optional[pulumi.Input[str]]):
        ...

    @property
    @pulumi.getter(name="volumeSize")
    def volume_size(self) -> Optional[pulumi.Input[float]]:
        """
        The size of created volumes in GiB.
        If `snapshot_id` is set and `volume_size` is omitted then the volume will have the same size
        as the selected snapshot.
        """
        ...

    @volume_size.setter
    def volume_size(self, value: Optional[pulumi.Input[float]]):
        ...

    @property
    @pulumi.getter(name="volumeType")
    def volume_type(self) -> Optional[pulumi.Input[str]]:
        """
        The type of EBS volume to create. Can be one of "standard" (the
        default), "io1" or "gp2".
        """
        ...

    @volume_type.setter
    def volume_type(self, value: Optional[pulumi.Input[str]]):
        ...


@pulumi.input_type
class AmiEphemeralBlockDeviceArgs:
    def __init__(__self__, *,
                 device_name: pulumi.Input[str],
                 virtual_name: pulumi.Input[str]):
        """
        :param pulumi.Input[str] device_name: The path at which the device is exposed to created instances.
        :param pulumi.Input[str] virtual_name: A name for the ephemeral device, of the form "ephemeralN" where
               *N* is a volume number starting from zero.
        """
        pulumi.set(__self__, "deviceName", device_name)
        pulumi.set(__self__, "virtualName", virtual_name)

    @property
    @pulumi.getter(name="deviceName")
    def device_name(self) -> pulumi.Input[str]:
        """
        The path at which the device is exposed to created instances.
        """
        ...

    @device_name.setter
    def device_name(self, value: pulumi.Input[str]):
        ...

    @property
    @pulumi.getter(name="virtualName")
    def virtual_name(self) -> pulumi.Input[str]:
        """
        A name for the ephemeral device, of the form "ephemeralN" where
        *N* is a volume number starting from zero.
        """
        ...

    @virtual_name.setter
    def virtual_name(self, value: pulumi.Input[str]):
        ...


@pulumi.input_type
class AmiFromInstanceEbsBlockDeviceArgs:
    def __init__(__self__, *,
                 delete_on_termination: Optional[pulumi.Input[bool]] = None,
                 device_name: Optional[pulumi.Input[str]] = None,
                 encrypted: Optional[pulumi.Input[bool]] = None,
                 iops: Optional[pulumi.Input[float]] = None,
                 snapshot_id: Optional[pulumi.Input[str]] = None,
                 volume_size: Optional[pulumi.Input[float]] = None,
                 volume_type: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[bool] delete_on_termination: Boolean controlling whether the EBS volumes created to
               support each created instance will be deleted once that instance is terminated.
        :param pulumi.Input[str] device_name: The path at which the device is exposed to created instances.
        :param pulumi.Input[bool] encrypted: Boolean controlling whether the created EBS volumes will be encrypted. Can't be used with `snapshot_id`.
        :param pulumi.Input[float] iops: Number of I/O operations per second the
               created volumes will support.
        :param pulumi.Input[str] snapshot_id: The id of an EBS snapshot that will be used to initialize the created
               EBS volumes. If set, the `volume_size` attribute must be at least as large as the referenced
               snapshot.
        :param pulumi.Input[float] volume_size: The size of created volumes in GiB.
               If `snapshot_id` is set and `volume_size` is omitted then the volume will have the same size
               as the selected snapshot.
        :param pulumi.Input[str] volume_type: The type of EBS volume to create. Can be one of "standard" (the
               default), "io1" or "gp2".
        """
        pulumi.set(__self__, "deleteOnTermination", delete_on_termination)
        pulumi.set(__self__, "deviceName", device_name)
        pulumi.set(__self__, "encrypted", encrypted)
        pulumi.set(__self__, "iops", iops)
        pulumi.set(__self__, "snapshotId", snapshot_id)
        pulumi.set(__self__, "volumeSize", volume_size)
        pulumi.set(__self__, "volumeType", volume_type)

    @property
    @pulumi.getter(name="deleteOnTermination")
    def delete_on_termination(self) -> Optional[pulumi.Input[bool]]:
        """
        Boolean controlling whether the EBS volumes created to
        support each created instance will be deleted once that instance is terminated.
        """
        ...

    @delete_on_termination.setter
    def delete_on_termination(self, value: Optional[pulumi.Input[bool]]):
        ...

    @property
    @pulumi.getter(name="deviceName")
    def device_name(self) -> Optional[pulumi.Input[str]]:
        """
        The path at which the device is exposed to created instances.
        """
        ...

    @device_name.setter
    def device_name(self, value: Optional[pulumi.Input[str]]):
        ...

    @property
    @pulumi.getter
    def encrypted(self) -> Optional[pulumi.Input[bool]]:
        """
        Boolean controlling whether the created EBS volumes will be encrypted. Can't be used with `snapshot_id`.
        """
        ...

    @encrypted.setter
    def encrypted(self, value: Optional[pulumi.Input[bool]]):
        ...

    @property
    @pulumi.getter
    def iops(self) -> Optional[pulumi.Input[float]]:
        """
        Number of I/O operations per second the
        created volumes will support.
        """
        ...

    @iops.setter
    def iops(self, value: Optional[pulumi.Input[float]]):
        ...

    @property
    @pulumi.getter(name="snapshotId")
    def snapshot_id(self) -> Optional[pulumi.Input[str]]:
        """
        The id of an EBS snapshot that will be used to initialize the created
        EBS volumes. If set, the `volume_size` attribute must be at least as large as the referenced
        snapshot.
        """
        ...

    @snapshot_id.setter
    def snapshot_id(self, value: Optional[pulumi.Input[str]]):
        ...

    @property
    @pulumi.getter(name="volumeSize")
    def volume_size(self) -> Optional[pulumi.Input[float]]:
        """
        The size of created volumes in GiB.
        If `snapshot_id` is set and `volume_size` is omitted then the volume will have the same size
        as the selected snapshot.
        """
        ...

    @volume_size.setter
    def volume_size(self, value: Optional[pulumi.Input[float]]):
        ...

    @property
    @pulumi.getter(name="volumeType")
    def volume_type(self) -> Optional[pulumi.Input[str]]:
        """
        The type of EBS volume to create. Can be one of "standard" (the
        default), "io1" or "gp2".
        """
        ...

    @volume_type.setter
    def volume_type(self, value: Optional[pulumi.Input[str]]):
        ...


@pulumi.input_type
class AmiFromInstanceEphemeralBlockDeviceArgs:
    def __init__(__self__, *,
                 device_name: Optional[pulumi.Input[str]] = None,
                 virtual_name: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] device_name: The path at which the device is exposed to created instances.
        :param pulumi.Input[str] virtual_name: A name for the ephemeral device, of the form "ephemeralN" where
               *N* is a volume number starting from zero.
        """
        pulumi.set(__self__, "deviceName", device_name)
        pulumi.set(__self__, "virtualName", virtual_name)

    @property
    @pulumi.getter(name="deviceName")
    def device_name(self) -> Optional[pulumi.Input[str]]:
        """
        The path at which the device is exposed to created instances.
        """
        ...

    @device_name.setter
    def device_name(self, value: Optional[pulumi.Input[str]]):
        ...

    @property
    @pulumi.getter(name="virtualName")
    def virtual_name(self) -> Optional[pulumi.Input[str]]:
        """
        A name for the ephemeral device, of the form "ephemeralN" where
        *N* is a volume number starting from zero.
        """
        ...

    @virtual_name.setter
    def virtual_name(self, value: Optional[pulumi.Input[str]]):
        ...


@pulumi.input_type
class DefaultNetworkAclEgressArgs:
    def __init__(__self__, *,
                 action: pulumi.Input[str],
                 from_port: pulumi.Input[float],
                 protocol: pulumi.Input[str],
                 rule_no: pulumi.Input[float],
                 to_port: pulumi.Input[float],
                 cidr_block: Optional[pulumi.Input[str]] = None,
                 icmp_code: Optional[pulumi.Input[float]] = None,
                 icmp_type: Optional[pulumi.Input[float]] = None,
                 ipv6_cidr_block: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] action: The action to take.
        :param pulumi.Input[float] from_port: The from port to match.
        :param pulumi.Input[str] protocol: The protocol to match. If using the -1 'all'
               protocol, you must specify a from and to port of 0.
        :param pulumi.Input[float] rule_no: The rule number. Used for ordering.
        :param pulumi.Input[float] to_port: The to port to match.
        :param pulumi.Input[str] cidr_block: The CIDR block to match. This must be a
               valid network mask.
        :param pulumi.Input[float] icmp_code: The ICMP type code to be used. Default 0.
        :param pulumi.Input[float] icmp_type: The ICMP type to be used. Default 0.
        :param pulumi.Input[str] ipv6_cidr_block: The IPv6 CIDR block.
        """
        pulumi.set(__self__, "action", action)
        pulumi.set(__self__, "fromPort", from_port)
        pulumi.set(__self__, "protocol", protocol)
        pulumi.set(__self__, "ruleNo", rule_no)
        pulumi.set(__self__, "toPort", to_port)
        pulumi.set(__self__, "cidrBlock", cidr_block)
        pulumi.set(__self__, "icmpCode", icmp_code)
        pulumi.set(__self__, "icmpType", icmp_type)
        pulumi.set(__self__, "ipv6CidrBlock", ipv6_cidr_block)

    @property
    @pulumi.getter
    def action(self) -> pulumi.Input[str]:
        """
        The action to take.
        """
        ...

    @action.setter
    def action(self, value: pulumi.Input[str]):
        ...

    @property
    @pulumi.getter(name="fromPort")
    def from_port(self) -> pulumi.Input[float]:
        """
        The from port to match.
        """
        ...

    @from_port.setter
    def from_port(self, value: pulumi.Input[float]):
        ...

    @property
    @pulumi.getter
    def protocol(self) -> pulumi.Input[str]:
        """
        The protocol to match. If using the -1 'all'
        protocol, you must specify a from and to port of 0.
        """
        ...

    @protocol.setter
    def protocol(self, value: pulumi.Input[str]):
        ...

    @property
    @pulumi.getter(name="ruleNo")
    def rule_no(self) -> pulumi.Input[float]:
        """
        The rule number. Used for ordering.
        """
        ...

    @rule_no.setter
    def rule_no(self, value: pulumi.Input[float]):
        ...

    @property
    @pulumi.getter(name="toPort")
    def to_port(self) -> pulumi.Input[float]:
        """
        The to port to match.
        """
        ...

    @to_port.setter
    def to_port(self, value: pulumi.Input[float]):
        ...

    @property
    @pulumi.getter(name="cidrBlock")
    def cidr_block(self) -> Optional[pulumi.Input[str]]:
        """
        The CIDR block to match. This must be a
        valid network mask.
        """
        ...

    @cidr_block.setter
    def cidr_block(self, value: Optional[pulumi.Input[str]]):
        ...

    @property
    @pulumi.getter(name="icmpCode")
    def icmp_code(self) -> Optional[pulumi.Input[float]]:
        """
        The ICMP type code to be used. Default 0.
        """
        ...

    @icmp_code.setter
    def icmp_code(self, value: Optional[pulumi.Input[float]]):
        ...

    @property
    @pulumi.getter(name="icmpType")
    def icmp_type(self) -> Optional[pulumi.Input[float]]:
        """
        The ICMP type to be used. Default 0.
        """
        ...

    @icmp_type.setter
    def icmp_type(self, value: Optional[pulumi.Input[float]]):
        ...

    @property
    @pulumi.getter(name="ipv6CidrBlock")
    def ipv6_cidr_block(self) -> Optional[pulumi.Input[str]]:
        """
        The IPv6 CIDR block.
        """
        ...

    @ipv6_cidr_block.setter
    def ipv6_cidr_block(self, value: Optional[pulumi.Input[str]]):
        ...


@pulumi.input_type
class DefaultNetworkAclIngressArgs:
    def __init__(__self__, *,
                 action: pulumi.Input[str],
                 from_port: pulumi.Input[float],
                 protocol: pulumi.Input[str],
                 rule_no: pulumi.Input[float],
                 to_port: pulumi.Input[float],
                 cidr_block: Optional[pulumi.Input[str]] = None,
                 icmp_code: Optional[pulumi.Input[float]] = None,
                 icmp_type: Optional[pulumi.Input[float]] = None,
                 ipv6_cidr_block: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] action: The action to take.
        :param pulumi.Input[float] from_port: The from port to match.
        :param pulumi.Input[str] protocol: The protocol to match. If using the -1 'all'
               protocol, you must specify a from and to port of 0.
        :param pulumi.Input[float] rule_no: The rule number. Used for ordering.
        :param pulumi.Input[float] to_port: The to port to match.
        :param pulumi.Input[str] cidr_block: The CIDR block to match. This must be a
               valid network mask.
        :param pulumi.Input[float] icmp_code: The ICMP type code to be used. Default 0.
        :param pulumi.Input[float] icmp_type: The ICMP type to be used. Default 0.
        :param pulumi.Input[str] ipv6_cidr_block: The IPv6 CIDR block.
        """
        pulumi.set(__self__, "action", action)
        pulumi.set(__self__, "fromPort", from_port)
        pulumi.set(__self__, "protocol", protocol)
        pulumi.set(__self__, "ruleNo", rule_no)
        pulumi.set(__self__, "toPort", to_port)
        pulumi.set(__self__, "cidrBlock", cidr_block)
        pulumi.set(__self__, "icmpCode", icmp_code)
        pulumi.set(__self__, "icmpType", icmp_type)
        pulumi.set(__self__, "ipv6CidrBlock", ipv6_cidr_block)

    @property
    @pulumi.getter
    def action(self) -> pulumi.Input[str]:
        """
        The action to take.
        """
        ...

    @action.setter
    def action(self, value: pulumi.Input[str]):
        ...

    @property
    @pulumi.getter(name="fromPort")
    def from_port(self) -> pulumi.Input[float]:
        """
        The from port to match.
        """
        ...

    @from_port.setter
    def from_port(self, value: pulumi.Input[float]):
        ...

    @property
    @pulumi.getter
    def protocol(self) -> pulumi.Input[str]:
        """
        The protocol to match. If using the -1 'all'
        protocol, you must specify a from and to port of 0.
        """
        ...

    @protocol.setter
    def protocol(self, value: pulumi.Input[str]):
        ...

    @property
    @pulumi.getter(name="ruleNo")
    def rule_no(self) -> pulumi.Input[float]:
        """
        The rule number. Used for ordering.
        """
        ...

    @rule_no.setter
    def rule_no(self, value: pulumi.Input[float]):
        ...

    @property
    @pulumi.getter(name="toPort")
    def to_port(self) -> pulumi.Input[float]:
        """
        The to port to match.
        """
        ...

    @to_port.setter
    def to_port(self, value: pulumi.Input[float]):
        ...

    @property
    @pulumi.getter(name="cidrBlock")
    def cidr_block(self) -> Optional[pulumi.Input[str]]:
        """
        The CIDR block to match. This must be a
        valid network mask.
        """
        ...

    @cidr_block.setter
    def cidr_block(self, value: Optional[pulumi.Input[str]]):
        ...

    @property
    @pulumi.getter(name="icmpCode")
    def icmp_code(self) -> Optional[pulumi.Input[float]]:
        """
        The ICMP type code to be used. Default 0.
        """
        ...

    @icmp_code.setter
    def icmp_code(self, value: Optional[pulumi.Input[float]]):
        ...

    @property
    @pulumi.getter(name="icmpType")
    def icmp_type(self) -> Optional[pulumi.Input[float]]:
        """
        The ICMP type to be used. Default 0.
        """
        ...

    @icmp_type.setter
    def icmp_type(self, value: Optional[pulumi.Input[float]]):
        ...

    @property
    @pulumi.getter(name="ipv6CidrBlock")
    def ipv6_cidr_block(self) -> Optional[pulumi.Input[str]]:
        """
        The IPv6 CIDR block.
        """
        ...

    @ipv6_cidr_block.setter
    def ipv6_cidr_block(self, value: Optional[pulumi.Input[str]]):
        ...


@pulumi.input_type
class DefaultRouteTableRouteArgs:
    def __init__(__self__, *,
                 cidr_block: Optional[pulumi.Input[str]] = None,
                 egress_only_gateway_id: Optional[pulumi.Input[str]] = None,
                 gateway_id: Optional[pulumi.Input[str]] = None,
                 instance_id: Optional[pulumi.Input[str]] = None,
                 ipv6_cidr_block: Optional[pulumi.Input[str]] = None,
                 nat_gateway_id: Optional[pulumi.Input[str]] = None,
                 network_interface_id: Optional[pulumi.Input[str]] = None,
                 transit_gateway_id: Optional[pulumi.Input[str]] = None,
                 vpc_peering_connection_id: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] cidr_block: The CIDR block of the route.
        :param pulumi.Input[str] egress_only_gateway_id: Identifier of a VPC Egress Only Internet Gateway.
        :param pulumi.Input[str] gateway_id: Identifier of a VPC internet gateway or a virtual private gateway.
        :param pulumi.Input[str] instance_id: Identifier of an EC2 instance.
        :param pulumi.Input[str] ipv6_cidr_block: The Ipv6 CIDR block of the route
        :param pulumi.Input[str] nat_gateway_id: Identifier of a VPC NAT gateway.
        :param pulumi.Input[str] network_interface_id: Identifier of an EC2 network interface.
        :param pulumi.Input[str] transit_gateway_id: Identifier of an EC2 Transit Gateway.
        :param pulumi.Input[str] vpc_peering_connection_id: Identifier of a VPC peering connection.
        """
        pulumi.set(__self__, "cidrBlock", cidr_block)
        pulumi.set(__self__, "egressOnlyGatewayId", egress_only_gateway_id)
        pulumi.set(__self__, "gatewayId", gateway_id)
        pulumi.set(__self__, "instanceId", instance_id)
        pulumi.set(__self__, "ipv6CidrBlock", ipv6_cidr_block)
        pulumi.set(__self__, "natGatewayId", nat_gateway_id)
        pulumi.set(__self__, "networkInterfaceId", network_interface_id)
        pulumi.set(__self__, "transitGatewayId", transit_gateway_id)
        pulumi.set(__self__, "vpcPeeringConnectionId", vpc_peering_connection_id)

    @property
    @pulumi.getter(name="cidrBlock")
    def cidr_block(self) -> Optional[pulumi.Input[str]]:
        """
        The CIDR block of the route.
        """
        ...

    @cidr_block.setter
    def cidr_block(self, value: Optional[pulumi.Input[str]]):
        ...

    @property
    @pulumi.getter(name="egressOnlyGatewayId")
    def egress_only_gateway_id(self) -> Optional[pulumi.Input[str]]:
        """
        Identifier of a VPC Egress Only Internet Gateway.
        """
        ...

    @egress_only_gateway_id.setter
    def egress_only_gateway_id(self, value: Optional[pulumi.Input[str]]):
        ...

    @property
    @pulumi.getter(name="gatewayId")
    def gateway_id(self) -> Optional[pulumi.Input[str]]:
        """
        Identifier of a VPC internet gateway or a virtual private gateway.
        """
        ...

    @gateway_id.setter
    def gateway_id(self, value: Optional[pulumi.Input[str]]):
        ...

    @property
    @pulumi.getter(name="instanceId")
    def instance_id(self) -> Optional[pulumi.Input[str]]:
        """
        Identifier of an EC2 instance.
        """
        ...

    @instance_id.setter
    def instance_id(self, value: Optional[pulumi.Input[str]]):
        ...

    @property
    @pulumi.getter(name="ipv6CidrBlock")
    def ipv6_cidr_block(self) -> Optional[pulumi.Input[str]]:
        """
        The Ipv6 CIDR block of the route
        """
        ...

    @ipv6_cidr_block.setter
    def ipv6_cidr_block(self, value: Optional[pulumi.Input[str]]):
        ...

    @property
    @pulumi.getter(name="natGatewayId")
    def nat_gateway_id(self) -> Optional[pulumi.Input[str]]:
        """
        Identifier of a VPC NAT gateway.
        """
        ...

    @nat_gateway_id.setter
    def nat_gateway_id(self, value: Optional[pulumi.Input[str]]):
        ...

    @property
    @pulumi.getter(name="networkInterfaceId")
    def network_interface_id(self) -> Optional[pulumi.Input[str]]:
        """
        Identifier of an EC2 network interface.
        """
        ...

    @network_interface_id.setter
    def network_interface_id(self, value: Optional[pulumi.Input[str]]):
        ...

    @property
    @pulumi.getter(name="transitGatewayId")
    def transit_gateway_id(self) -> Optional[pulumi.Input[str]]:
        """
        Identifier of an EC2 Transit Gateway.
        """
        ...

    @transit_gateway_id.setter
    def transit_gateway_id(self, value: Optional[pulumi.Input[str]]):
        ...

    @property
    @pulumi.getter(name="vpcPeeringConnectionId")
    def vpc_peering_connection_id(self) -> Optional[pulumi.Input[str]]:
        """
        Identifier of a VPC peering connection.
        """
        ...

    @vpc_peering_connection_id.setter
    def vpc_peering_connection_id(self, value: Optional[pulumi.Input[str]]):
        ...


@pulumi.input_type
class DefaultSecurityGroupEgressArgs:
    def __init__(__self__, *,
                 from_port: pulumi.Input[float],
                 protocol: pulumi.Input[str],
                 to_port: pulumi.Input[float],
                 cidr_blocks: Optional[pulumi.Input[List[pulumi.Input[str]]]] = None,
                 description: Optional[pulumi.Input[str]] = None,
                 ipv6_cidr_blocks: Optional[pulumi.Input[List[pulumi.Input[str]]]] = None,
                 prefix_list_ids: Optional[pulumi.Input[List[pulumi.Input[str]]]] = None,
                 security_groups: Optional[pulumi.Input[List[pulumi.Input[str]]]] = None,
                 self: Optional[pulumi.Input[bool]] = None):
        """
        :param pulumi.Input[str] description: The description of the security group
        """
        pulumi.set(__self__, "fromPort", from_port)
        pulumi.set(__self__, "protocol", protocol)
        pulumi.set(__self__, "toPort", to_port)
        pulumi.set(__self__, "cidrBlocks", cidr_blocks)
        pulumi.set(__self__, "description", description)
        pulumi.set(__self__, "ipv6CidrBlocks", ipv6_cidr_blocks)
        pulumi.set(__self__, "prefixListIds", prefix_list_ids)
        pulumi.set(__self__, "securityGroups", security_groups)
        pulumi.set(__self__, "self", self)

    @property
    @pulumi.getter(name="fromPort")
    def from_port(self) -> pulumi.Input[float]:
        ...

    @from_port.setter
    def from_port(self, value: pulumi.Input[float]):
        ...

    @property
    @pulumi.getter
    def protocol(self) -> pulumi.Input[str]:
        ...

    @protocol.setter
    def protocol(self, value: pulumi.Input[str]):
        ...

    @property
    @pulumi.getter(name="toPort")
    def to_port(self) -> pulumi.Input[float]:
        ...

    @to_port.setter
    def to_port(self, value: pulumi.Input[float]):
        ...

    @property
    @pulumi.getter(name="cidrBlocks")
    def cidr_blocks(self) -> Optional[pulumi.Input[List[pulumi.Input[str]]]]:
        ...

    @cidr_blocks.setter
    def cidr_blocks(self, value: Optional[pulumi.Input[List[pulumi.Input[str]]]]):
        ...

    @property
    @pulumi.getter
    def description(self) -> Optional[pulumi.Input[str]]:
        """
        The description of the security group
        """
        ...

    @description.setter
    def description(self, value: Optional[pulumi.Input[str]]):
        ...

    @property
    @pulumi.getter(name="ipv6CidrBlocks")
    def ipv6_cidr_blocks(self) -> Optional[pulumi.Input[List[pulumi.Input[str]]]]:
        ...

    @ipv6_cidr_blocks.setter
    def ipv6_cidr_blocks(self, value: Optional[pulumi.Input[List[pulumi.Input[str]]]]):
        ...

    @property
    @pulumi.getter(name="prefixListIds")
    def prefix_list_ids(self) -> Optional[pulumi.Input[List[pulumi.Input[str]]]]:
        ...

    @prefix_list_ids.setter
    def prefix_list_ids(self, value: Optional[pulumi.Input[List[pulumi.Input[str]]]]):
        ...

    @property
    @pulumi.getter(name="securityGroups")
    def security_groups(self) -> Optional[pulumi.Input[List[pulumi.Input[str]]]]:
        ...

    @security_groups.setter
    def security_groups(self, value: Optional[pulumi.Input[List[pulumi.Input[str]]]]):
        ...

    @property
    @pulumi.getter
    def self(self) -> Optional[pulumi.Input[bool]]:
        ...

    @self.setter
    def self(self, value: Optional[pulumi.Input[bool]]):
        ...


@pulumi.input_type
class DefaultSecurityGroupIngressArgs:
    def __init__(__self__, *,
                 from_port: pulumi.Input[float],
                 protocol: pulumi.Input[str],
                 to_port: pulumi.Input[float],
                 cidr_blocks: Optional[pulumi.Input[List[pulumi.Input[str]]]] = None,
                 description: Optional[pulumi.Input[str]] = None,
                 ipv6_cidr_blocks: Optional[pulumi.Input[List[pulumi.Input[str]]]] = None,
                 prefix_list_ids: Optional[pulumi.Input[List[pulumi.Input[str]]]] = None,
                 security_groups: Optional[pulumi.Input[List[pulumi.Input[str]]]] = None,
                 self: Optional[pulumi.Input[bool]] = None):
        """
        :param pulumi.Input[str] description: The description of the security group
        """
        pulumi.set(__self__, "fromPort", from_port)
        pulumi.set(__self__, "protocol", protocol)
        pulumi.set(__self__, "toPort", to_port)
        pulumi.set(__self__, "cidrBlocks", cidr_blocks)
        pulumi.set(__self__, "description", description)
        pulumi.set(__self__, "ipv6CidrBlocks", ipv6_cidr_blocks)
        pulumi.set(__self__, "prefixListIds", prefix_list_ids)
        pulumi.set(__self__, "securityGroups", security_groups)
        pulumi.set(__self__, "self", self)

    @property
    @pulumi.getter(name="fromPort")
    def from_port(self) -> pulumi.Input[float]:
        ...

    @from_port.setter
    def from_port(self, value: pulumi.Input[float]):
        ...

    @property
    @pulumi.getter
    def protocol(self) -> pulumi.Input[str]:
        ...

    @protocol.setter
    def protocol(self, value: pulumi.Input[str]):
        ...

    @property
    @pulumi.getter(name="toPort")
    def to_port(self) -> pulumi.Input[float]:
        ...

    @to_port.setter
    def to_port(self, value: pulumi.Input[float]):
        ...

    @property
    @pulumi.getter(name="cidrBlocks")
    def cidr_blocks(self) -> Optional[pulumi.Input[List[pulumi.Input[str]]]]:
        ...

    @cidr_blocks.setter
    def cidr_blocks(self, value: Optional[pulumi.Input[List[pulumi.Input[str]]]]):
        ...

    @property
    @pulumi.getter
    def description(self) -> Optional[pulumi.Input[str]]:
        """
        The description of the security group
        """
        ...

    @description.setter
    def description(self, value: Optional[pulumi.Input[str]]):
        ...

    @property
    @pulumi.getter(name="ipv6CidrBlocks")
    def ipv6_cidr_blocks(self) -> Optional[pulumi.Input[List[pulumi.Input[str]]]]:
        ...

    @ipv6_cidr_blocks.setter
    def ipv6_cidr_blocks(self, value: Optional[pulumi.Input[List[pulumi.Input[str]]]]):
        ...

    @property
    @pulumi.getter(name="prefixListIds")
    def prefix_list_ids(self) -> Optional[pulumi.Input[List[pulumi.Input[str]]]]:
        ...

    @prefix_list_ids.setter
    def prefix_list_ids(self, value: Optional[pulumi.Input[List[pulumi.Input[str]]]]):
        ...

    @property
    @pulumi.getter(name="securityGroups")
    def security_groups(self) -> Optional[pulumi.Input[List[pulumi.Input[str]]]]:
        ...

    @security_groups.setter
    def security_groups(self, value: Optional[pulumi.Input[List[pulumi.Input[str]]]]):
        ...

    @property
    @pulumi.getter
    def self(self) -> Optional[pulumi.Input[bool]]:
        ...

    @self.setter
    def self(self, value: Optional[pulumi.Input[bool]]):
        ...


@pulumi.input_type
class FleetLaunchTemplateConfigArgs:
    def __init__(__self__, *,
                 launch_template_specification: pulumi.Input['FleetLaunchTemplateConfigLaunchTemplateSpecificationArgs'],
                 overrides: Optional[pulumi.Input[List[pulumi.Input['FleetLaunchTemplateConfigOverrideArgs']]]] = None):
        """
        :param pulumi.Input['FleetLaunchTemplateConfigLaunchTemplateSpecificationArgs'] launch_template_specification: Nested argument containing EC2 Launch Template to use. Defined below.
        :param pulumi.Input[List[pulumi.Input['FleetLaunchTemplateConfigOverrideArgs']]] overrides: Nested argument(s) containing parameters to override the same parameters in the Launch Template. Defined below.
        """
        pulumi.set(__self__, "launchTemplateSpecification", launch_template_specification)
        pulumi.set(__self__, "overrides", overrides)

    @property
    @pulumi.getter(name="launchTemplateSpecification")
    def launch_template_specification(self) -> pulumi.Input['FleetLaunchTemplateConfigLaunchTemplateSpecificationArgs']:
        """
        Nested argument containing EC2 Launch Template to use. Defined below.
        """
        ...

    @launch_template_specification.setter
    def launch_template_specification(self, value: pulumi.Input['FleetLaunchTemplateConfigLaunchTemplateSpecificationArgs']):
        ...

    @property
    @pulumi.getter
    def overrides(self) -> Optional[pulumi.Input[List[pulumi.Input['FleetLaunchTemplateConfigOverrideArgs']]]]:
        """
        Nested argument(s) containing parameters to override the same parameters in the Launch Template. Defined below.
        """
        ...

    @overrides.setter
    def overrides(self, value: Optional[pulumi.Input[List[pulumi.Input['FleetLaunchTemplateConfigOverrideArgs']]]]):
        ...


@pulumi.input_type
class FleetLaunchTemplateConfigLaunchTemplateSpecificationArgs:
    def __init__(__self__, *,
                 version: pulumi.Input[str],
                 launch_template_id: Optional[pulumi.Input[str]] = None,
                 launch_template_name: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] version: Version number of the launch template.
        :param pulumi.Input[str] launch_template_id: ID of the launch template.
        :param pulumi.Input[str] launch_template_name: Name of the launch template.
        """
        pulumi.set(__self__, "version", version)
        pulumi.set(__self__, "launchTemplateId", launch_template_id)
        pulumi.set(__self__, "launchTemplateName", launch_template_name)

    @property
    @pulumi.getter
    def version(self) -> pulumi.Input[str]:
        """
        Version number of the launch template.
        """
        ...

    @version.setter
    def version(self, value: pulumi.Input[str]):
        ...

    @property
    @pulumi.getter(name="launchTemplateId")
    def launch_template_id(self) -> Optional[pulumi.Input[str]]:
        """
        ID of the launch template.
        """
        ...

    @launch_template_id.setter
    def launch_template_id(self, value: Optional[pulumi.Input[str]]):
        ...

    @property
    @pulumi.getter(name="launchTemplateName")
    def launch_template_name(self) -> Optional[pulumi.Input[str]]:
        """
        Name of the launch template.
        """
        ...

    @launch_template_name.setter
    def launch_template_name(self, value: Optional[pulumi.Input[str]]):
        ...


@pulumi.input_type
class FleetLaunchTemplateConfigOverrideArgs:
    def __init__(__self__, *,
                 availability_zone: Optional[pulumi.Input[str]] = None,
                 instance_type: Optional[pulumi.Input[str]] = None,
                 max_price: Optional[pulumi.Input[str]] = None,
                 priority: Optional[pulumi.Input[float]] = None,
                 subnet_id: Optional[pulumi.Input[str]] = None,
                 weighted_capacity: Optional[pulumi.Input[float]] = None):
        """
        :param pulumi.Input[str] availability_zone: Availability Zone in which to launch the instances.
        :param pulumi.Input[str] instance_type: Instance type.
        :param pulumi.Input[str] max_price: Maximum price per unit hour that you are willing to pay for a Spot Instance.
        :param pulumi.Input[float] priority: Priority for the launch template override. If `on_demand_options` `allocation_strategy` is set to `prioritized`, EC2 Fleet uses priority to determine which launch template override to use first in fulfilling On-Demand capacity. The highest priority is launched first. The lower the number, the higher the priority. If no number is set, the launch template override has the lowest priority. Valid values are whole numbers starting at 0.
        :param pulumi.Input[str] subnet_id: ID of the subnet in which to launch the instances.
        :param pulumi.Input[float] weighted_capacity: Number of units provided by the specified instance type.
        """
        pulumi.set(__self__, "availabilityZone", availability_zone)
        pulumi.set(__self__, "instanceType", instance_type)
        pulumi.set(__self__, "maxPrice", max_price)
        pulumi.set(__self__, "priority", priority)
        pulumi.set(__self__, "subnetId", subnet_id)
        pulumi.set(__self__, "weightedCapacity", weighted_capacity)

    @property
    @pulumi.getter(name="availabilityZone")
    def availability_zone(self) -> Optional[pulumi.Input[str]]:
        """
        Availability Zone in which to launch the instances.
        """
        ...

    @availability_zone.setter
    def availability_zone(self, value: Optional[pulumi.Input[str]]):
        ...

    @property
    @pulumi.getter(name="instanceType")
    def instance_type(self) -> Optional[pulumi.Input[str]]:
        """
        Instance type.
        """
        ...

    @instance_type.setter
    def instance_type(self, value: Optional[pulumi.Input[str]]):
        ...

    @property
    @pulumi.getter(name="maxPrice")
    def max_price(self) -> Optional[pulumi.Input[str]]:
        """
        Maximum price per unit hour that you are willing to pay for a Spot Instance.
        """
        ...

    @max_price.setter
    def max_price(self, value: Optional[pulumi.Input[str]]):
        ...

    @property
    @pulumi.getter
    def priority(self) -> Optional[pulumi.Input[float]]:
        """
        Priority for the launch template override. If `on_demand_options` `allocation_strategy` is set to `prioritized`, EC2 Fleet uses priority to determine which launch template override to use first in fulfilling On-Demand capacity. The highest priority is launched first. The lower the number, the higher the priority. If no number is set, the launch template override has the lowest priority. Valid values are whole numbers starting at 0.
        """
        ...

    @priority.setter
    def priority(self, value: Optional[pulumi.Input[float]]):
        ...

    @property
    @pulumi.getter(name="subnetId")
    def subnet_id(self) -> Optional[pulumi.Input[str]]:
        """
        ID of the subnet in which to launch the instances.
        """
        ...

    @subnet_id.setter
    def subnet_id(self, value: Optional[pulumi.Input[str]]):
        ...

    @property
    @pulumi.getter(name="weightedCapacity")
    def weighted_capacity(self) -> Optional[pulumi.Input[float]]:
        """
        Number of units provided by the specified instance type.
        """
        ...

    @weighted_capacity.setter
    def weighted_capacity(self, value: Optional[pulumi.Input[float]]):
        ...


@pulumi.input_type
class FleetOnDemandOptionsArgs:
    def __init__(__self__, *,
                 allocation_strategy: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] allocation_strategy: How to allocate the target capacity across the Spot pools. Valid values: `diversified`, `lowestPrice`. Default: `lowestPrice`.
        """
        pulumi.set(__self__, "allocationStrategy", allocation_strategy)

    @property
    @pulumi.getter(name="allocationStrategy")
    def allocation_strategy(self) -> Optional[pulumi.Input[str]]:
        """
        How to allocate the target capacity across the Spot pools. Valid values: `diversified`, `lowestPrice`. Default: `lowestPrice`.
        """
        ...

    @allocation_strategy.setter
    def allocation_strategy(self, value: Optional[pulumi.Input[str]]):
        ...


@pulumi.input_type
class FleetSpotOptionsArgs:
    def __init__(__self__, *,
                 allocation_strategy: Optional[pulumi.Input[str]] = None,
                 instance_interruption_behavior: Optional[pulumi.Input[str]] = None,
                 instance_pools_to_use_count: Optional[pulumi.Input[float]] = None):
        """
        :param pulumi.Input[str] allocation_strategy: How to allocate the target capacity across the Spot pools. Valid values: `diversified`, `lowestPrice`. Default: `lowestPrice`.
        :param pulumi.Input[str] instance_interruption_behavior: Behavior when a Spot Instance is interrupted. Valid values: `hibernate`, `stop`, `terminate`. Default: `terminate`.
        :param pulumi.Input[float] instance_pools_to_use_count: Number of Spot pools across which to allocate your target Spot capacity. Valid only when Spot `allocation_strategy` is set to `lowestPrice`. Default: `1`.
        """
        pulumi.set(__self__, "allocationStrategy", allocation_strategy)
        pulumi.set(__self__, "instanceInterruptionBehavior", instance_interruption_behavior)
        pulumi.set(__self__, "instancePoolsToUseCount", instance_pools_to_use_count)

    @property
    @pulumi.getter(name="allocationStrategy")
    def allocation_strategy(self) -> Optional[pulumi.Input[str]]:
        """
        How to allocate the target capacity across the Spot pools. Valid values: `diversified`, `lowestPrice`. Default: `lowestPrice`.
        """
        ...

    @allocation_strategy.setter
    def allocation_strategy(self, value: Optional[pulumi.Input[str]]):
        ...

    @property
    @pulumi.getter(name="instanceInterruptionBehavior")
    def instance_interruption_behavior(self) -> Optional[pulumi.Input[str]]:
        """
        Behavior when a Spot Instance is interrupted. Valid values: `hibernate`, `stop`, `terminate`. Default: `terminate`.
        """
        ...

    @instance_interruption_behavior.setter
    def instance_interruption_behavior(self, value: Optional[pulumi.Input[str]]):
        ...

    @property
    @pulumi.getter(name="instancePoolsToUseCount")
    def instance_pools_to_use_count(self) -> Optional[pulumi.Input[float]]:
        """
        Number of Spot pools across which to allocate your target Spot capacity. Valid only when Spot `allocation_strategy` is set to `lowestPrice`. Default: `1`.
        """
        ...

    @instance_pools_to_use_count.setter
    def instance_pools_to_use_count(self, value: Optional[pulumi.Input[float]]):
        ...


@pulumi.input_type
class FleetTargetCapacitySpecificationArgs:
    def __init__(__self__, *,
                 default_target_capacity_type: pulumi.Input[str],
                 total_target_capacity: pulumi.Input[float],
                 on_demand_target_capacity: Optional[pulumi.Input[float]] = None,
                 spot_target_capacity: Optional[pulumi.Input[float]] = None):
        """
        :param pulumi.Input[str] default_target_capacity_type: Default target capacity type. Valid values: `on-demand`, `spot`.
        :param pulumi.Input[float] total_target_capacity: The number of units to request, filled using `default_target_capacity_type`.
        :param pulumi.Input[float] on_demand_target_capacity: The number of On-Demand units to request.
        :param pulumi.Input[float] spot_target_capacity: The number of Spot units to request.
        """
        pulumi.set(__self__, "defaultTargetCapacityType", default_target_capacity_type)
        pulumi.set(__self__, "totalTargetCapacity", total_target_capacity)
        pulumi.set(__self__, "onDemandTargetCapacity", on_demand_target_capacity)
        pulumi.set(__self__, "spotTargetCapacity", spot_target_capacity)

    @property
    @pulumi.getter(name="defaultTargetCapacityType")
    def default_target_capacity_type(self) -> pulumi.Input[str]:
        """
        Default target capacity type. Valid values: `on-demand`, `spot`.
        """
        ...

    @default_target_capacity_type.setter
    def default_target_capacity_type(self, value: pulumi.Input[str]):
        ...

    @property
    @pulumi.getter(name="totalTargetCapacity")
    def total_target_capacity(self) -> pulumi.Input[float]:
        """
        The number of units to request, filled using `default_target_capacity_type`.
        """
        ...

    @total_target_capacity.setter
    def total_target_capacity(self, value: pulumi.Input[float]):
        ...

    @property
    @pulumi.getter(name="onDemandTargetCapacity")
    def on_demand_target_capacity(self) -> Optional[pulumi.Input[float]]:
        """
        The number of On-Demand units to request.
        """
        ...

    @on_demand_target_capacity.setter
    def on_demand_target_capacity(self, value: Optional[pulumi.Input[float]]):
        ...

    @property
    @pulumi.getter(name="spotTargetCapacity")
    def spot_target_capacity(self) -> Optional[pulumi.Input[float]]:
        """
        The number of Spot units to request.
        """
        ...

    @spot_target_capacity.setter
    def spot_target_capacity(self, value: Optional[pulumi.Input[float]]):
        ...


@pulumi.input_type
class InstanceCreditSpecificationArgs:
    def __init__(__self__, *,
                 cpu_credits: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] cpu_credits: The credit option for CPU usage. Can be `"standard"` or `"unlimited"`. T3 instances are launched as unlimited by default. T2 instances are launched as standard by default.
        """
        pulumi.set(__self__, "cpuCredits", cpu_credits)

    @property
    @pulumi.getter(name="cpuCredits")
    def cpu_credits(self) -> Optional[pulumi.Input[str]]:
        """
        The credit option for CPU usage. Can be `"standard"` or `"unlimited"`. T3 instances are launched as unlimited by default. T2 instances are launched as standard by default.
        """
        ...

    @cpu_credits.setter
    def cpu_credits(self, value: Optional[pulumi.Input[str]]):
        ...


@pulumi.input_type
class InstanceEbsBlockDeviceArgs:
    def __init__(__self__, *,
                 device_name: pulumi.Input[str],
                 delete_on_termination: Optional[pulumi.Input[bool]] = None,
                 encrypted: Optional[pulumi.Input[bool]] = None,
                 iops: Optional[pulumi.Input[float]] = None,
                 kms_key_id: Optional[pulumi.Input[str]] = None,
                 snapshot_id: Optional[pulumi.Input[str]] = None,
                 volume_id: Optional[pulumi.Input[str]] = None,
                 volume_size: Optional[pulumi.Input[float]] = None,
                 volume_type: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] device_name: The name of the device to mount.
        :param pulumi.Input[bool] delete_on_termination: Whether the volume should be destroyed
               on instance termination (Default: `true`).
        :param pulumi.Input[bool] encrypted: Enables [EBS
               encryption](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/EBSEncryption.html)
               on the volume (Default: `false`). Cannot be used with `snapshot_id`. Must be configured to perform drift detection.
        :param pulumi.Input[float] iops: The amount of provisioned
               [IOPS](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/ebs-io-characteristics.html).
               This must be set with a `volume_type` of `"io1"`.
        :param pulumi.Input[str] kms_key_id: Amazon Resource Name (ARN) of the KMS Key to use when encrypting the volume. Must be configured to perform drift detection.
        :param pulumi.Input[str] snapshot_id: The Snapshot ID to mount.
        :param pulumi.Input[float] volume_size: The size of the volume in gibibytes (GiB).
        :param pulumi.Input[str] volume_type: The type of volume. Can be `"standard"`, `"gp2"`,
               or `"io1"`. (Default: `"gp2"`).
        """
        pulumi.set(__self__, "deviceName", device_name)
        pulumi.set(__self__, "deleteOnTermination", delete_on_termination)
        pulumi.set(__self__, "encrypted", encrypted)
        pulumi.set(__self__, "iops", iops)
        pulumi.set(__self__, "kmsKeyId", kms_key_id)
        pulumi.set(__self__, "snapshotId", snapshot_id)
        pulumi.set(__self__, "volumeId", volume_id)
        pulumi.set(__self__, "volumeSize", volume_size)
        pulumi.set(__self__, "volumeType", volume_type)

    @property
    @pulumi.getter(name="deviceName")
    def device_name(self) -> pulumi.Input[str]:
        """
        The name of the device to mount.
        """
        ...

    @device_name.setter
    def device_name(self, value: pulumi.Input[str]):
        ...

    @property
    @pulumi.getter(name="deleteOnTermination")
    def delete_on_termination(self) -> Optional[pulumi.Input[bool]]:
        """
        Whether the volume should be destroyed
        on instance termination (Default: `true`).
        """
        ...

    @delete_on_termination.setter
    def delete_on_termination(self, value: Optional[pulumi.Input[bool]]):
        ...

    @property
    @pulumi.getter
    def encrypted(self) -> Optional[pulumi.Input[bool]]:
        """
        Enables [EBS
        encryption](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/EBSEncryption.html)
        on the volume (Default: `false`). Cannot be used with `snapshot_id`. Must be configured to perform drift detection.
        """
        ...

    @encrypted.setter
    def encrypted(self, value: Optional[pulumi.Input[bool]]):
        ...

    @property
    @pulumi.getter
    def iops(self) -> Optional[pulumi.Input[float]]:
        """
        The amount of provisioned
        [IOPS](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/ebs-io-characteristics.html).
        This must be set with a `volume_type` of `"io1"`.
        """
        ...

    @iops.setter
    def iops(self, value: Optional[pulumi.Input[float]]):
        ...

    @property
    @pulumi.getter(name="kmsKeyId")
    def kms_key_id(self) -> Optional[pulumi.Input[str]]:
        """
        Amazon Resource Name (ARN) of the KMS Key to use when encrypting the volume. Must be configured to perform drift detection.
        """
        ...

    @kms_key_id.setter
    def kms_key_id(self, value: Optional[pulumi.Input[str]]):
        ...

    @property
    @pulumi.getter(name="snapshotId")
    def snapshot_id(self) -> Optional[pulumi.Input[str]]:
        """
        The Snapshot ID to mount.
        """
        ...

    @snapshot_id.setter
    def snapshot_id(self, value: Optional[pulumi.Input[str]]):
        ...

    @property
    @pulumi.getter(name="volumeId")
    def volume_id(self) -> Optional[pulumi.Input[str]]:
        ...

    @volume_id.setter
    def volume_id(self, value: Optional[pulumi.Input[str]]):
        ...

    @property
    @pulumi.getter(name="volumeSize")
    def volume_size(self) -> Optional[pulumi.Input[float]]:
        """
        The size of the volume in gibibytes (GiB).
        """
        ...

    @volume_size.setter
    def volume_size(self, value: Optional[pulumi.Input[float]]):
        ...

    @property
    @pulumi.getter(name="volumeType")
    def volume_type(self) -> Optional[pulumi.Input[str]]:
        """
        The type of volume. Can be `"standard"`, `"gp2"`,
        or `"io1"`. (Default: `"gp2"`).
        """
        ...

    @volume_type.setter
    def volume_type(self, value: Optional[pulumi.Input[str]]):
        ...


@pulumi.input_type
class InstanceEphemeralBlockDeviceArgs:
    def __init__(__self__, *,
                 device_name: pulumi.Input[str],
                 no_device: Optional[pulumi.Input[bool]] = None,
                 virtual_name: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] device_name: The name of the block device to mount on the instance.
        :param pulumi.Input[bool] no_device: Suppresses the specified device included in the AMI's block device mapping.
        :param pulumi.Input[str] virtual_name: The [Instance Store Device
               Name](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/InstanceStorage.html#InstanceStoreDeviceNames)
               (e.g. `"ephemeral0"`).
        """
        pulumi.set(__self__, "deviceName", device_name)
        pulumi.set(__self__, "noDevice", no_device)
        pulumi.set(__self__, "virtualName", virtual_name)

    @property
    @pulumi.getter(name="deviceName")
    def device_name(self) -> pulumi.Input[str]:
        """
        The name of the block device to mount on the instance.
        """
        ...

    @device_name.setter
    def device_name(self, value: pulumi.Input[str]):
        ...

    @property
    @pulumi.getter(name="noDevice")
    def no_device(self) -> Optional[pulumi.Input[bool]]:
        """
        Suppresses the specified device included in the AMI's block device mapping.
        """
        ...

    @no_device.setter
    def no_device(self, value: Optional[pulumi.Input[bool]]):
        ...

    @property
    @pulumi.getter(name="virtualName")
    def virtual_name(self) -> Optional[pulumi.Input[str]]:
        """
        The [Instance Store Device
        Name](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/InstanceStorage.html#InstanceStoreDeviceNames)
        (e.g. `"ephemeral0"`).
        """
        ...

    @virtual_name.setter
    def virtual_name(self, value: Optional[pulumi.Input[str]]):
        ...


@pulumi.input_type
class InstanceMetadataOptionsArgs:
    def __init__(__self__, *,
                 http_endpoint: Optional[pulumi.Input[str]] = None,
                 http_put_response_hop_limit: Optional[pulumi.Input[float]] = None,
                 http_tokens: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] http_endpoint: Whether the metadata service is available. Can be `"enabled"` or `"disabled"`. (Default: `"enabled"`).
        :param pulumi.Input[float] http_put_response_hop_limit: The desired HTTP PUT response hop limit for instance metadata requests. The larger the number, the further instance metadata requests can travel. Can be an integer from `1` to `64`. (Default: `1`).
        :param pulumi.Input[str] http_tokens: Whether or not the metadata service requires session tokens, also referred to as _Instance Metadata Service Version 2_. Can be `"optional"` or `"required"`. (Default: `"optional"`).
        """
        pulumi.set(__self__, "httpEndpoint", http_endpoint)
        pulumi.set(__self__, "httpPutResponseHopLimit", http_put_response_hop_limit)
        pulumi.set(__self__, "httpTokens", http_tokens)

    @property
    @pulumi.getter(name="httpEndpoint")
    def http_endpoint(self) -> Optional[pulumi.Input[str]]:
        """
        Whether the metadata service is available. Can be `"enabled"` or `"disabled"`. (Default: `"enabled"`).
        """
        ...

    @http_endpoint.setter
    def http_endpoint(self, value: Optional[pulumi.Input[str]]):
        ...

    @property
    @pulumi.getter(name="httpPutResponseHopLimit")
    def http_put_response_hop_limit(self) -> Optional[pulumi.Input[float]]:
        """
        The desired HTTP PUT response hop limit for instance metadata requests. The larger the number, the further instance metadata requests can travel. Can be an integer from `1` to `64`. (Default: `1`).
        """
        ...

    @http_put_response_hop_limit.setter
    def http_put_response_hop_limit(self, value: Optional[pulumi.Input[float]]):
        ...

    @property
    @pulumi.getter(name="httpTokens")
    def http_tokens(self) -> Optional[pulumi.Input[str]]:
        """
        Whether or not the metadata service requires session tokens, also referred to as _Instance Metadata Service Version 2_. Can be `"optional"` or `"required"`. (Default: `"optional"`).
        """
        ...

    @http_tokens.setter
    def http_tokens(self, value: Optional[pulumi.Input[str]]):
        ...


@pulumi.input_type
class InstanceNetworkInterfaceArgs:
    def __init__(__self__, *,
                 device_index: pulumi.Input[float],
                 network_interface_id: pulumi.Input[str],
                 delete_on_termination: Optional[pulumi.Input[bool]] = None):
        """
        :param pulumi.Input[float] device_index: The integer index of the network interface attachment. Limited by instance type.
        :param pulumi.Input[str] network_interface_id: The ID of the network interface to attach.
        :param pulumi.Input[bool] delete_on_termination: Whether or not to delete the network interface on instance termination. Defaults to `false`. Currently, the only valid value is `false`, as this is only supported when creating new network interfaces when launching an instance.
        """
        pulumi.set(__self__, "deviceIndex", device_index)
        pulumi.set(__self__, "networkInterfaceId", network_interface_id)
        pulumi.set(__self__, "deleteOnTermination", delete_on_termination)

    @property
    @pulumi.getter(name="deviceIndex")
    def device_index(self) -> pulumi.Input[float]:
        """
        The integer index of the network interface attachment. Limited by instance type.
        """
        ...

    @device_index.setter
    def device_index(self, value: pulumi.Input[float]):
        ...

    @property
    @pulumi.getter(name="networkInterfaceId")
    def network_interface_id(self) -> pulumi.Input[str]:
        """
        The ID of the network interface to attach.
        """
        ...

    @network_interface_id.setter
    def network_interface_id(self, value: pulumi.Input[str]):
        ...

    @property
    @pulumi.getter(name="deleteOnTermination")
    def delete_on_termination(self) -> Optional[pulumi.Input[bool]]:
        """
        Whether or not to delete the network interface on instance termination. Defaults to `false`. Currently, the only valid value is `false`, as this is only supported when creating new network interfaces when launching an instance.
        """
        ...

    @delete_on_termination.setter
    def delete_on_termination(self, value: Optional[pulumi.Input[bool]]):
        ...


@pulumi.input_type
class InstanceRootBlockDeviceArgs:
    def __init__(__self__, *,
                 delete_on_termination: Optional[pulumi.Input[bool]] = None,
                 device_name: Optional[pulumi.Input[str]] = None,
                 encrypted: Optional[pulumi.Input[bool]] = None,
                 iops: Optional[pulumi.Input[float]] = None,
                 kms_key_id: Optional[pulumi.Input[str]] = None,
                 volume_id: Optional[pulumi.Input[str]] = None,
                 volume_size: Optional[pulumi.Input[float]] = None,
                 volume_type: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[bool] delete_on_termination: Whether the volume should be destroyed
               on instance termination (Default: `true`).
        :param pulumi.Input[str] device_name: The name of the device to mount.
        :param pulumi.Input[bool] encrypted: Enable volume encryption. (Default: `false`). Must be configured to perform drift detection.
        :param pulumi.Input[float] iops: The amount of provisioned
               [IOPS](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/ebs-io-characteristics.html).
               This is only valid for `volume_type` of `"io1"`, and must be specified if
               using that type
        :param pulumi.Input[str] kms_key_id: Amazon Resource Name (ARN) of the KMS Key to use when encrypting the volume. Must be configured to perform drift detection.
        :param pulumi.Input[float] volume_size: The size of the volume in gibibytes (GiB).
        :param pulumi.Input[str] volume_type: The type of volume. Can be `"standard"`, `"gp2"`, `"io1"`, `"sc1"`, or `"st1"`. (Default: `"standard"`).
        """
        pulumi.set(__self__, "deleteOnTermination", delete_on_termination)
        pulumi.set(__self__, "deviceName", device_name)
        pulumi.set(__self__, "encrypted", encrypted)
        pulumi.set(__self__, "iops", iops)
        pulumi.set(__self__, "kmsKeyId", kms_key_id)
        pulumi.set(__self__, "volumeId", volume_id)
        pulumi.set(__self__, "volumeSize", volume_size)
        pulumi.set(__self__, "volumeType", volume_type)

    @property
    @pulumi.getter(name="deleteOnTermination")
    def delete_on_termination(self) -> Optional[pulumi.Input[bool]]:
        """
        Whether the volume should be destroyed
        on instance termination (Default: `true`).
        """
        ...

    @delete_on_termination.setter
    def delete_on_termination(self, value: Optional[pulumi.Input[bool]]):
        ...

    @property
    @pulumi.getter(name="deviceName")
    def device_name(self) -> Optional[pulumi.Input[str]]:
        """
        The name of the device to mount.
        """
        ...

    @device_name.setter
    def device_name(self, value: Optional[pulumi.Input[str]]):
        ...

    @property
    @pulumi.getter
    def encrypted(self) -> Optional[pulumi.Input[bool]]:
        """
        Enable volume encryption. (Default: `false`). Must be configured to perform drift detection.
        """
        ...

    @encrypted.setter
    def encrypted(self, value: Optional[pulumi.Input[bool]]):
        ...

    @property
    @pulumi.getter
    def iops(self) -> Optional[pulumi.Input[float]]:
        """
        The amount of provisioned
        [IOPS](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/ebs-io-characteristics.html).
        This is only valid for `volume_type` of `"io1"`, and must be specified if
        using that type
        """
        ...

    @iops.setter
    def iops(self, value: Optional[pulumi.Input[float]]):
        ...

    @property
    @pulumi.getter(name="kmsKeyId")
    def kms_key_id(self) -> Optional[pulumi.Input[str]]:
        """
        Amazon Resource Name (ARN) of the KMS Key to use when encrypting the volume. Must be configured to perform drift detection.
        """
        ...

    @kms_key_id.setter
    def kms_key_id(self, value: Optional[pulumi.Input[str]]):
        ...

    @property
    @pulumi.getter(name="volumeId")
    def volume_id(self) -> Optional[pulumi.Input[str]]:
        ...

    @volume_id.setter
    def volume_id(self, value: Optional[pulumi.Input[str]]):
        ...

    @property
    @pulumi.getter(name="volumeSize")
    def volume_size(self) -> Optional[pulumi.Input[float]]:
        """
        The size of the volume in gibibytes (GiB).
        """
        ...

    @volume_size.setter
    def volume_size(self, value: Optional[pulumi.Input[float]]):
        ...

    @property
    @pulumi.getter(name="volumeType")
    def volume_type(self) -> Optional[pulumi.Input[str]]:
        """
        The type of volume. Can be `"standard"`, `"gp2"`, `"io1"`, `"sc1"`, or `"st1"`. (Default: `"standard"`).
        """
        ...

    @volume_type.setter
    def volume_type(self, value: Optional[pulumi.Input[str]]):
        ...


@pulumi.input_type
class LaunchConfigurationEbsBlockDeviceArgs:
    def __init__(__self__, *,
                 device_name: pulumi.Input[str],
                 delete_on_termination: Optional[pulumi.Input[bool]] = None,
                 encrypted: Optional[pulumi.Input[bool]] = None,
                 iops: Optional[pulumi.Input[float]] = None,
                 no_device: Optional[pulumi.Input[bool]] = None,
                 snapshot_id: Optional[pulumi.Input[str]] = None,
                 volume_size: Optional[pulumi.Input[float]] = None,
                 volume_type: Optional[pulumi.Input[str]] = None):
        pulumi.set(__self__, "deviceName", device_name)
        pulumi.set(__self__, "deleteOnTermination", delete_on_termination)
        pulumi.set(__self__, "encrypted", encrypted)
        pulumi.set(__self__, "iops", iops)
        pulumi.set(__self__, "noDevice", no_device)
        pulumi.set(__self__, "snapshotId", snapshot_id)
        pulumi.set(__self__, "volumeSize", volume_size)
        pulumi.set(__self__, "volumeType", volume_type)

    @property
    @pulumi.getter(name="deviceName")
    def device_name(self) -> pulumi.Input[str]:
        ...

    @device_name.setter
    def device_name(self, value: pulumi.Input[str]):
        ...

    @property
    @pulumi.getter(name="deleteOnTermination")
    def delete_on_termination(self) -> Optional[pulumi.Input[bool]]:
        ...

    @delete_on_termination.setter
    def delete_on_termination(self, value: Optional[pulumi.Input[bool]]):
        ...

    @property
    @pulumi.getter
    def encrypted(self) -> Optional[pulumi.Input[bool]]:
        ...

    @encrypted.setter
    def encrypted(self, value: Optional[pulumi.Input[bool]]):
        ...

    @property
    @pulumi.getter
    def iops(self) -> Optional[pulumi.Input[float]]:
        ...

    @iops.setter
    def iops(self, value: Optional[pulumi.Input[float]]):
        ...

    @property
    @pulumi.getter(name="noDevice")
    def no_device(self) -> Optional[pulumi.Input[bool]]:
        ...

    @no_device.setter
    def no_device(self, value: Optional[pulumi.Input[bool]]):
        ...

    @property
    @pulumi.getter(name="snapshotId")
    def snapshot_id(self) -> Optional[pulumi.Input[str]]:
        ...

    @snapshot_id.setter
    def snapshot_id(self, value: Optional[pulumi.Input[str]]):
        ...

    @property
    @pulumi.getter(name="volumeSize")
    def volume_size(self) -> Optional[pulumi.Input[float]]:
        ...

    @volume_size.setter
    def volume_size(self, value: Optional[pulumi.Input[float]]):
        ...

    @property
    @pulumi.getter(name="volumeType")
    def volume_type(self) -> Optional[pulumi.Input[str]]:
        ...

    @volume_type.setter
    def volume_type(self, value: Optional[pulumi.Input[str]]):
        ...


@pulumi.input_type
class LaunchConfigurationEphemeralBlockDeviceArgs:
    def __init__(__self__, *,
                 device_name: pulumi.Input[str],
                 virtual_name: pulumi.Input[str]):
        pulumi.set(__self__, "deviceName", device_name)
        pulumi.set(__self__, "virtualName", virtual_name)

    @property
    @pulumi.getter(name="deviceName")
    def device_name(self) -> pulumi.Input[str]:
        ...

    @device_name.setter
    def device_name(self, value: pulumi.Input[str]):
        ...

    @property
    @pulumi.getter(name="virtualName")
    def virtual_name(self) -> pulumi.Input[str]:
        ...

    @virtual_name.setter
    def virtual_name(self, value: pulumi.Input[str]):
        ...


@pulumi.input_type
class LaunchConfigurationRootBlockDeviceArgs:
    def __init__(__self__, *,
                 delete_on_termination: Optional[pulumi.Input[bool]] = None,
                 encrypted: Optional[pulumi.Input[bool]] = None,
                 iops: Optional[pulumi.Input[float]] = None,
                 volume_size: Optional[pulumi.Input[float]] = None,
                 volume_type: Optional[pulumi.Input[str]] = None):
        pulumi.set(__self__, "deleteOnTermination", delete_on_termination)
        pulumi.set(__self__, "encrypted", encrypted)
        pulumi.set(__self__, "iops", iops)
        pulumi.set(__self__, "volumeSize", volume_size)
        pulumi.set(__self__, "volumeType", volume_type)

    @property
    @pulumi.getter(name="deleteOnTermination")
    def delete_on_termination(self) -> Optional[pulumi.Input[bool]]:
        ...

    @delete_on_termination.setter
    def delete_on_termination(self, value: Optional[pulumi.Input[bool]]):
        ...

    @property
    @pulumi.getter
    def encrypted(self) -> Optional[pulumi.Input[bool]]:
        ...

    @encrypted.setter
    def encrypted(self, value: Optional[pulumi.Input[bool]]):
        ...

    @property
    @pulumi.getter
    def iops(self) -> Optional[pulumi.Input[float]]:
        ...

    @iops.setter
    def iops(self, value: Optional[pulumi.Input[float]]):
        ...

    @property
    @pulumi.getter(name="volumeSize")
    def volume_size(self) -> Optional[pulumi.Input[float]]:
        ...

    @volume_size.setter
    def volume_size(self, value: Optional[pulumi.Input[float]]):
        ...

    @property
    @pulumi.getter(name="volumeType")
    def volume_type(self) -> Optional[pulumi.Input[str]]:
        ...

    @volume_type.setter
    def volume_type(self, value: Optional[pulumi.Input[str]]):
        ...


@pulumi.input_type
class LaunchTemplateBlockDeviceMappingArgs:
    def __init__(__self__, *,
                 device_name: Optional[pulumi.Input[str]] = None,
                 ebs: Optional[pulumi.Input['LaunchTemplateBlockDeviceMappingEbsArgs']] = None,
                 no_device: Optional[pulumi.Input[str]] = None,
                 virtual_name: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] device_name: The name of the device to mount.
        :param pulumi.Input['LaunchTemplateBlockDeviceMappingEbsArgs'] ebs: Configure EBS volume properties.
        :param pulumi.Input[str] no_device: Suppresses the specified device included in the AMI's block device mapping.
        :param pulumi.Input[str] virtual_name: The [Instance Store Device
               Name](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/InstanceStorage.html#InstanceStoreDeviceNames)
               (e.g. `"ephemeral0"`).
        """
        pulumi.set(__self__, "deviceName", device_name)
        pulumi.set(__self__, "ebs", ebs)
        pulumi.set(__self__, "noDevice", no_device)
        pulumi.set(__self__, "virtualName", virtual_name)

    @property
    @pulumi.getter(name="deviceName")
    def device_name(self) -> Optional[pulumi.Input[str]]:
        """
        The name of the device to mount.
        """
        ...

    @device_name.setter
    def device_name(self, value: Optional[pulumi.Input[str]]):
        ...

    @property
    @pulumi.getter
    def ebs(self) -> Optional[pulumi.Input['LaunchTemplateBlockDeviceMappingEbsArgs']]:
        """
        Configure EBS volume properties.
        """
        ...

    @ebs.setter
    def ebs(self, value: Optional[pulumi.Input['LaunchTemplateBlockDeviceMappingEbsArgs']]):
        ...

    @property
    @pulumi.getter(name="noDevice")
    def no_device(self) -> Optional[pulumi.Input[str]]:
        """
        Suppresses the specified device included in the AMI's block device mapping.
        """
        ...

    @no_device.setter
    def no_device(self, value: Optional[pulumi.Input[str]]):
        ...

    @property
    @pulumi.getter(name="virtualName")
    def virtual_name(self) -> Optional[pulumi.Input[str]]:
        """
        The [Instance Store Device
        Name](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/InstanceStorage.html#InstanceStoreDeviceNames)
        (e.g. `"ephemeral0"`).
        """
        ...

    @virtual_name.setter
    def virtual_name(self, value: Optional[pulumi.Input[str]]):
        ...


@pulumi.input_type
class LaunchTemplateBlockDeviceMappingEbsArgs:
    def __init__(__self__, *,
                 delete_on_termination: Optional[pulumi.Input[str]] = None,
                 encrypted: Optional[pulumi.Input[str]] = None,
                 iops: Optional[pulumi.Input[float]] = None,
                 kms_key_id: Optional[pulumi.Input[str]] = None,
                 snapshot_id: Optional[pulumi.Input[str]] = None,
                 volume_size: Optional[pulumi.Input[float]] = None,
                 volume_type: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] delete_on_termination: Whether the volume should be destroyed on instance termination. Defaults to `false` if not set. See [Preserving Amazon EBS Volumes on Instance Termination](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/terminating-instances.html#preserving-volumes-on-termination) for more information.
        :param pulumi.Input[str] encrypted: Enables [EBS encryption](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/EBSEncryption.html)
               on the volume (Default: `false`). Cannot be used with `snapshot_id`.
        :param pulumi.Input[float] iops: The amount of provisioned
               [IOPS](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/ebs-io-characteristics.html).
               This must be set with a `volume_type` of `"io1"`.
        :param pulumi.Input[str] kms_key_id: The ARN of the AWS Key Management Service (AWS KMS) customer master key (CMK) to use when creating the encrypted volume.
               `encrypted` must be set to `true` when this is set.
        :param pulumi.Input[str] snapshot_id: The Snapshot ID to mount.
        :param pulumi.Input[float] volume_size: The size of the volume in gigabytes.
        :param pulumi.Input[str] volume_type: The type of volume. Can be `"standard"`, `"gp2"`, or `"io1"`. (Default: `"standard"`).
        """
        pulumi.set(__self__, "deleteOnTermination", delete_on_termination)
        pulumi.set(__self__, "encrypted", encrypted)
        pulumi.set(__self__, "iops", iops)
        pulumi.set(__self__, "kmsKeyId", kms_key_id)
        pulumi.set(__self__, "snapshotId", snapshot_id)
        pulumi.set(__self__, "volumeSize", volume_size)
        pulumi.set(__self__, "volumeType", volume_type)

    @property
    @pulumi.getter(name="deleteOnTermination")
    def delete_on_termination(self) -> Optional[pulumi.Input[str]]:
        """
        Whether the volume should be destroyed on instance termination. Defaults to `false` if not set. See [Preserving Amazon EBS Volumes on Instance Termination](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/terminating-instances.html#preserving-volumes-on-termination) for more information.
        """
        ...

    @delete_on_termination.setter
    def delete_on_termination(self, value: Optional[pulumi.Input[str]]):
        ...

    @property
    @pulumi.getter
    def encrypted(self) -> Optional[pulumi.Input[str]]:
        """
        Enables [EBS encryption](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/EBSEncryption.html)
        on the volume (Default: `false`). Cannot be used with `snapshot_id`.
        """
        ...

    @encrypted.setter
    def encrypted(self, value: Optional[pulumi.Input[str]]):
        ...

    @property
    @pulumi.getter
    def iops(self) -> Optional[pulumi.Input[float]]:
        """
        The amount of provisioned
        [IOPS](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/ebs-io-characteristics.html).
        This must be set with a `volume_type` of `"io1"`.
        """
        ...

    @iops.setter
    def iops(self, value: Optional[pulumi.Input[float]]):
        ...

    @property
    @pulumi.getter(name="kmsKeyId")
    def kms_key_id(self) -> Optional[pulumi.Input[str]]:
        """
        The ARN of the AWS Key Management Service (AWS KMS) customer master key (CMK) to use when creating the encrypted volume.
        `encrypted` must be set to `true` when this is set.
        """
        ...

    @kms_key_id.setter
    def kms_key_id(self, value: Optional[pulumi.Input[str]]):
        ...

    @property
    @pulumi.getter(name="snapshotId")
    def snapshot_id(self) -> Optional[pulumi.Input[str]]:
        """
        The Snapshot ID to mount.
        """
        ...

    @snapshot_id.setter
    def snapshot_id(self, value: Optional[pulumi.Input[str]]):
        ...

    @property
    @pulumi.getter(name="volumeSize")
    def volume_size(self) -> Optional[pulumi.Input[float]]:
        """
        The size of the volume in gigabytes.
        """
        ...

    @volume_size.setter
    def volume_size(self, value: Optional[pulumi.Input[float]]):
        ...

    @property
    @pulumi.getter(name="volumeType")
    def volume_type(self) -> Optional[pulumi.Input[str]]:
        """
        The type of volume. Can be `"standard"`, `"gp2"`, or `"io1"`. (Default: `"standard"`).
        """
        ...

    @volume_type.setter
    def volume_type(self, value: Optional[pulumi.Input[str]]):
        ...


@pulumi.input_type
class LaunchTemplateCapacityReservationSpecificationArgs:
    def __init__(__self__, *,
                 capacity_reservation_preference: Optional[pulumi.Input[str]] = None,
                 capacity_reservation_target: Optional[pulumi.Input['LaunchTemplateCapacityReservationSpecificationCapacityReservationTargetArgs']] = None):
        """
        :param pulumi.Input[str] capacity_reservation_preference: Indicates the instance's Capacity Reservation preferences. Can be `open` or `none`. (Default `none`).
        :param pulumi.Input['LaunchTemplateCapacityReservationSpecificationCapacityReservationTargetArgs'] capacity_reservation_target: Used to target a specific Capacity Reservation:
        """
        pulumi.set(__self__, "capacityReservationPreference", capacity_reservation_preference)
        pulumi.set(__self__, "capacityReservationTarget", capacity_reservation_target)

    @property
    @pulumi.getter(name="capacityReservationPreference")
    def capacity_reservation_preference(self) -> Optional[pulumi.Input[str]]:
        """
        Indicates the instance's Capacity Reservation preferences. Can be `open` or `none`. (Default `none`).
        """
        ...

    @capacity_reservation_preference.setter
    def capacity_reservation_preference(self, value: Optional[pulumi.Input[str]]):
        ...

    @property
    @pulumi.getter(name="capacityReservationTarget")
    def capacity_reservation_target(self) -> Optional[pulumi.Input['LaunchTemplateCapacityReservationSpecificationCapacityReservationTargetArgs']]:
        """
        Used to target a specific Capacity Reservation:
        """
        ...

    @capacity_reservation_target.setter
    def capacity_reservation_target(self, value: Optional[pulumi.Input['LaunchTemplateCapacityReservationSpecificationCapacityReservationTargetArgs']]):
        ...


@pulumi.input_type
class LaunchTemplateCapacityReservationSpecificationCapacityReservationTargetArgs:
    def __init__(__self__, *,
                 capacity_reservation_id: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] capacity_reservation_id: The ID of the Capacity Reservation to target.
        """
        pulumi.set(__self__, "capacityReservationId", capacity_reservation_id)

    @property
    @pulumi.getter(name="capacityReservationId")
    def capacity_reservation_id(self) -> Optional[pulumi.Input[str]]:
        """
        The ID of the Capacity Reservation to target.
        """
        ...

    @capacity_reservation_id.setter
    def capacity_reservation_id(self, value: Optional[pulumi.Input[str]]):
        ...


@pulumi.input_type
class LaunchTemplateCpuOptionsArgs:
    def __init__(__self__, *,
                 core_count: Optional[pulumi.Input[float]] = None,
                 threads_per_core: Optional[pulumi.Input[float]] = None):
        """
        :param pulumi.Input[float] core_count: The number of CPU cores for the instance.
        :param pulumi.Input[float] threads_per_core: The number of threads per CPU core. To disable Intel Hyper-Threading Technology for the instance, specify a value of 1.
               Otherwise, specify the default value of 2.
        """
        pulumi.set(__self__, "coreCount", core_count)
        pulumi.set(__self__, "threadsPerCore", threads_per_core)

    @property
    @pulumi.getter(name="coreCount")
    def core_count(self) -> Optional[pulumi.Input[float]]:
        """
        The number of CPU cores for the instance.
        """
        ...

    @core_count.setter
    def core_count(self, value: Optional[pulumi.Input[float]]):
        ...

    @property
    @pulumi.getter(name="threadsPerCore")
    def threads_per_core(self) -> Optional[pulumi.Input[float]]:
        """
        The number of threads per CPU core. To disable Intel Hyper-Threading Technology for the instance, specify a value of 1.
        Otherwise, specify the default value of 2.
        """
        ...

    @threads_per_core.setter
    def threads_per_core(self, value: Optional[pulumi.Input[float]]):
        ...


@pulumi.input_type
class LaunchTemplateCreditSpecificationArgs:
    def __init__(__self__, *,
                 cpu_credits: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] cpu_credits: The credit option for CPU usage. Can be `"standard"` or `"unlimited"`. T3 instances are launched as unlimited by default. T2 instances are launched as standard by default.
        """
        pulumi.set(__self__, "cpuCredits", cpu_credits)

    @property
    @pulumi.getter(name="cpuCredits")
    def cpu_credits(self) -> Optional[pulumi.Input[str]]:
        """
        The credit option for CPU usage. Can be `"standard"` or `"unlimited"`. T3 instances are launched as unlimited by default. T2 instances are launched as standard by default.
        """
        ...

    @cpu_credits.setter
    def cpu_credits(self, value: Optional[pulumi.Input[str]]):
        ...


@pulumi.input_type
class LaunchTemplateElasticGpuSpecificationArgs:
    def __init__(__self__, *,
                 type: pulumi.Input[str]):
        """
        :param pulumi.Input[str] type: The [Elastic GPU Type](https://docs.aws.amazon.com/AWSEC2/latest/WindowsGuide/elastic-gpus.html#elastic-gpus-basics)
        """
        pulumi.set(__self__, "type", type)

    @property
    @pulumi.getter
    def type(self) -> pulumi.Input[str]:
        """
        The [Elastic GPU Type](https://docs.aws.amazon.com/AWSEC2/latest/WindowsGuide/elastic-gpus.html#elastic-gpus-basics)
        """
        ...

    @type.setter
    def type(self, value: pulumi.Input[str]):
        ...


@pulumi.input_type
class LaunchTemplateElasticInferenceAcceleratorArgs:
    def __init__(__self__, *,
                 type: pulumi.Input[str]):
        """
        :param pulumi.Input[str] type: Accelerator type.
        """
        pulumi.set(__self__, "type", type)

    @property
    @pulumi.getter
    def type(self) -> pulumi.Input[str]:
        """
        Accelerator type.
        """
        ...

    @type.setter
    def type(self, value: pulumi.Input[str]):
        ...


@pulumi.input_type
class LaunchTemplateHibernationOptionsArgs:
    def __init__(__self__, *,
                 configured: pulumi.Input[bool]):
        """
        :param pulumi.Input[bool] configured: If set to `true`, the launched EC2 instance will hibernation enabled.
        """
        pulumi.set(__self__, "configured", configured)

    @property
    @pulumi.getter
    def configured(self) -> pulumi.Input[bool]:
        """
        If set to `true`, the launched EC2 instance will hibernation enabled.
        """
        ...

    @configured.setter
    def configured(self, value: pulumi.Input[bool]):
        ...


@pulumi.input_type
class LaunchTemplateIamInstanceProfileArgs:
    def __init__(__self__, *,
                 arn: Optional[pulumi.Input[str]] = None,
                 name: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] arn: The Amazon Resource Name (ARN) of the instance profile.
        :param pulumi.Input[str] name: The name of the instance profile.
        """
        pulumi.set(__self__, "arn", arn)
        pulumi.set(__self__, "name", name)

    @property
    @pulumi.getter
    def arn(self) -> Optional[pulumi.Input[str]]:
        """
        The Amazon Resource Name (ARN) of the instance profile.
        """
        ...

    @arn.setter
    def arn(self, value: Optional[pulumi.Input[str]]):
        ...

    @property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[str]]:
        """
        The name of the instance profile.
        """
        ...

    @name.setter
    def name(self, value: Optional[pulumi.Input[str]]):
        ...


@pulumi.input_type
class LaunchTemplateInstanceMarketOptionsArgs:
    def __init__(__self__, *,
                 market_type: Optional[pulumi.Input[str]] = None,
                 spot_options: Optional[pulumi.Input['LaunchTemplateInstanceMarketOptionsSpotOptionsArgs']] = None):
        """
        :param pulumi.Input[str] market_type: The market type. Can be `spot`.
        :param pulumi.Input['LaunchTemplateInstanceMarketOptionsSpotOptionsArgs'] spot_options: The options for [Spot Instance](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/using-spot-instances.html)
        """
        pulumi.set(__self__, "marketType", market_type)
        pulumi.set(__self__, "spotOptions", spot_options)

    @property
    @pulumi.getter(name="marketType")
    def market_type(self) -> Optional[pulumi.Input[str]]:
        """
        The market type. Can be `spot`.
        """
        ...

    @market_type.setter
    def market_type(self, value: Optional[pulumi.Input[str]]):
        ...

    @property
    @pulumi.getter(name="spotOptions")
    def spot_options(self) -> Optional[pulumi.Input['LaunchTemplateInstanceMarketOptionsSpotOptionsArgs']]:
        """
        The options for [Spot Instance](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/using-spot-instances.html)
        """
        ...

    @spot_options.setter
    def spot_options(self, value: Optional[pulumi.Input['LaunchTemplateInstanceMarketOptionsSpotOptionsArgs']]):
        ...


@pulumi.input_type
class LaunchTemplateInstanceMarketOptionsSpotOptionsArgs:
    def __init__(__self__, *,
                 block_duration_minutes: Optional[pulumi.Input[float]] = None,
                 instance_interruption_behavior: Optional[pulumi.Input[str]] = None,
                 max_price: Optional[pulumi.Input[str]] = None,
                 spot_instance_type: Optional[pulumi.Input[str]] = None,
                 valid_until: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[float] block_duration_minutes: The required duration in minutes. This value must be a multiple of 60.
        :param pulumi.Input[str] instance_interruption_behavior: The behavior when a Spot Instance is interrupted. Can be `hibernate`,
               `stop`, or `terminate`. (Default: `terminate`).
        :param pulumi.Input[str] max_price: The maximum hourly price you're willing to pay for the Spot Instances.
        :param pulumi.Input[str] spot_instance_type: The Spot Instance request type. Can be `one-time`, or `persistent`.
        :param pulumi.Input[str] valid_until: The end date of the request.
        """
        pulumi.set(__self__, "blockDurationMinutes", block_duration_minutes)
        pulumi.set(__self__, "instanceInterruptionBehavior", instance_interruption_behavior)
        pulumi.set(__self__, "maxPrice", max_price)
        pulumi.set(__self__, "spotInstanceType", spot_instance_type)
        pulumi.set(__self__, "validUntil", valid_until)

    @property
    @pulumi.getter(name="blockDurationMinutes")
    def block_duration_minutes(self) -> Optional[pulumi.Input[float]]:
        """
        The required duration in minutes. This value must be a multiple of 60.
        """
        ...

    @block_duration_minutes.setter
    def block_duration_minutes(self, value: Optional[pulumi.Input[float]]):
        ...

    @property
    @pulumi.getter(name="instanceInterruptionBehavior")
    def instance_interruption_behavior(self) -> Optional[pulumi.Input[str]]:
        """
        The behavior when a Spot Instance is interrupted. Can be `hibernate`,
        `stop`, or `terminate`. (Default: `terminate`).
        """
        ...

    @instance_interruption_behavior.setter
    def instance_interruption_behavior(self, value: Optional[pulumi.Input[str]]):
        ...

    @property
    @pulumi.getter(name="maxPrice")
    def max_price(self) -> Optional[pulumi.Input[str]]:
        """
        The maximum hourly price you're willing to pay for the Spot Instances.
        """
        ...

    @max_price.setter
    def max_price(self, value: Optional[pulumi.Input[str]]):
        ...

    @property
    @pulumi.getter(name="spotInstanceType")
    def spot_instance_type(self) -> Optional[pulumi.Input[str]]:
        """
        The Spot Instance request type. Can be `one-time`, or `persistent`.
        """
        ...

    @spot_instance_type.setter
    def spot_instance_type(self, value: Optional[pulumi.Input[str]]):
        ...

    @property
    @pulumi.getter(name="validUntil")
    def valid_until(self) -> Optional[pulumi.Input[str]]:
        """
        The end date of the request.
        """
        ...

    @valid_until.setter
    def valid_until(self, value: Optional[pulumi.Input[str]]):
        ...


@pulumi.input_type
class LaunchTemplateLicenseSpecificationArgs:
    def __init__(__self__, *,
                 license_configuration_arn: pulumi.Input[str]):
        """
        :param pulumi.Input[str] license_configuration_arn: ARN of the license configuration.
        """
        pulumi.set(__self__, "licenseConfigurationArn", license_configuration_arn)

    @property
    @pulumi.getter(name="licenseConfigurationArn")
    def license_configuration_arn(self) -> pulumi.Input[str]:
        """
        ARN of the license configuration.
        """
        ...

    @license_configuration_arn.setter
    def license_configuration_arn(self, value: pulumi.Input[str]):
        ...


@pulumi.input_type
class LaunchTemplateMetadataOptionsArgs:
    def __init__(__self__, *,
                 http_endpoint: Optional[pulumi.Input[str]] = None,
                 http_put_response_hop_limit: Optional[pulumi.Input[float]] = None,
                 http_tokens: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] http_endpoint: Whether the metadata service is available. Can be `"enabled"` or `"disabled"`. (Default: `"enabled"`).
        :param pulumi.Input[float] http_put_response_hop_limit: The desired HTTP PUT response hop limit for instance metadata requests. The larger the number, the further instance metadata requests can travel. Can be an integer from `1` to `64`. (Default: `1`).
        :param pulumi.Input[str] http_tokens: Whether or not the metadata service requires session tokens, also referred to as _Instance Metadata Service Version 2_. Can be `"optional"` or `"required"`. (Default: `"optional"`).
        """
        pulumi.set(__self__, "httpEndpoint", http_endpoint)
        pulumi.set(__self__, "httpPutResponseHopLimit", http_put_response_hop_limit)
        pulumi.set(__self__, "httpTokens", http_tokens)

    @property
    @pulumi.getter(name="httpEndpoint")
    def http_endpoint(self) -> Optional[pulumi.Input[str]]:
        """
        Whether the metadata service is available. Can be `"enabled"` or `"disabled"`. (Default: `"enabled"`).
        """
        ...

    @http_endpoint.setter
    def http_endpoint(self, value: Optional[pulumi.Input[str]]):
        ...

    @property
    @pulumi.getter(name="httpPutResponseHopLimit")
    def http_put_response_hop_limit(self) -> Optional[pulumi.Input[float]]:
        """
        The desired HTTP PUT response hop limit for instance metadata requests. The larger the number, the further instance metadata requests can travel. Can be an integer from `1` to `64`. (Default: `1`).
        """
        ...

    @http_put_response_hop_limit.setter
    def http_put_response_hop_limit(self, value: Optional[pulumi.Input[float]]):
        ...

    @property
    @pulumi.getter(name="httpTokens")
    def http_tokens(self) -> Optional[pulumi.Input[str]]:
        """
        Whether or not the metadata service requires session tokens, also referred to as _Instance Metadata Service Version 2_. Can be `"optional"` or `"required"`. (Default: `"optional"`).
        """
        ...

    @http_tokens.setter
    def http_tokens(self, value: Optional[pulumi.Input[str]]):
        ...


@pulumi.input_type
class LaunchTemplateMonitoringArgs:
    def __init__(__self__, *,
                 enabled: Optional[pulumi.Input[bool]] = None):
        """
        :param pulumi.Input[bool] enabled: If `true`, the launched EC2 instance will have detailed monitoring enabled.
        """
        pulumi.set(__self__, "enabled", enabled)

    @property
    @pulumi.getter
    def enabled(self) -> Optional[pulumi.Input[bool]]:
        """
        If `true`, the launched EC2 instance will have detailed monitoring enabled.
        """
        ...

    @enabled.setter
    def enabled(self, value: Optional[pulumi.Input[bool]]):
        ...


@pulumi.input_type
class LaunchTemplateNetworkInterfaceArgs:
    def __init__(__self__, *,
                 associate_public_ip_address: Optional[pulumi.Input[str]] = None,
                 delete_on_termination: Optional[pulumi.Input[bool]] = None,
                 description: Optional[pulumi.Input[str]] = None,
                 device_index: Optional[pulumi.Input[float]] = None,
                 ipv4_address_count: Optional[pulumi.Input[float]] = None,
                 ipv4_addresses: Optional[pulumi.Input[List[pulumi.Input[str]]]] = None,
                 ipv6_address_count: Optional[pulumi.Input[float]] = None,
                 ipv6_addresses: Optional[pulumi.Input[List[pulumi.Input[str]]]] = None,
                 network_interface_id: Optional[pulumi.Input[str]] = None,
                 private_ip_address: Optional[pulumi.Input[str]] = None,
                 security_groups: Optional[pulumi.Input[List[pulumi.Input[str]]]] = None,
                 subnet_id: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] associate_public_ip_address: Associate a public ip address with the network interface.  Boolean value.
        :param pulumi.Input[bool] delete_on_termination: Whether the network interface should be destroyed on instance termination. Defaults to `false` if not set.
        :param pulumi.Input[str] description: Description of the network interface.
        :param pulumi.Input[float] device_index: The integer index of the network interface attachment.
        :param pulumi.Input[float] ipv4_address_count: The number of secondary private IPv4 addresses to assign to a network interface. Conflicts with `ipv4_addresses`
        :param pulumi.Input[List[pulumi.Input[str]]] ipv4_addresses: One or more private IPv4 addresses to associate. Conflicts with `ipv4_address_count`
        :param pulumi.Input[float] ipv6_address_count: The number of IPv6 addresses to assign to a network interface. Conflicts with `ipv6_addresses`
        :param pulumi.Input[List[pulumi.Input[str]]] ipv6_addresses: One or more specific IPv6 addresses from the IPv6 CIDR block range of your subnet. Conflicts with `ipv6_address_count`
        :param pulumi.Input[str] network_interface_id: The ID of the network interface to attach.
        :param pulumi.Input[str] private_ip_address: The primary private IPv4 address.
        :param pulumi.Input[List[pulumi.Input[str]]] security_groups: A list of security group IDs to associate.
        :param pulumi.Input[str] subnet_id: The VPC Subnet ID to associate.
        """
        pulumi.set(__self__, "associatePublicIpAddress", associate_public_ip_address)
        pulumi.set(__self__, "deleteOnTermination", delete_on_termination)
        pulumi.set(__self__, "description", description)
        pulumi.set(__self__, "deviceIndex", device_index)
        pulumi.set(__self__, "ipv4AddressCount", ipv4_address_count)
        pulumi.set(__self__, "ipv4Addresses", ipv4_addresses)
        pulumi.set(__self__, "ipv6AddressCount", ipv6_address_count)
        pulumi.set(__self__, "ipv6Addresses", ipv6_addresses)
        pulumi.set(__self__, "networkInterfaceId", network_interface_id)
        pulumi.set(__self__, "privateIpAddress", private_ip_address)
        pulumi.set(__self__, "securityGroups", security_groups)
        pulumi.set(__self__, "subnetId", subnet_id)

    @property
    @pulumi.getter(name="associatePublicIpAddress")
    def associate_public_ip_address(self) -> Optional[pulumi.Input[str]]:
        """
        Associate a public ip address with the network interface.  Boolean value.
        """
        ...

    @associate_public_ip_address.setter
    def associate_public_ip_address(self, value: Optional[pulumi.Input[str]]):
        ...

    @property
    @pulumi.getter(name="deleteOnTermination")
    def delete_on_termination(self) -> Optional[pulumi.Input[bool]]:
        """
        Whether the network interface should be destroyed on instance termination. Defaults to `false` if not set.
        """
        ...

    @delete_on_termination.setter
    def delete_on_termination(self, value: Optional[pulumi.Input[bool]]):
        ...

    @property
    @pulumi.getter
    def description(self) -> Optional[pulumi.Input[str]]:
        """
        Description of the network interface.
        """
        ...

    @description.setter
    def description(self, value: Optional[pulumi.Input[str]]):
        ...

    @property
    @pulumi.getter(name="deviceIndex")
    def device_index(self) -> Optional[pulumi.Input[float]]:
        """
        The integer index of the network interface attachment.
        """
        ...

    @device_index.setter
    def device_index(self, value: Optional[pulumi.Input[float]]):
        ...

    @property
    @pulumi.getter(name="ipv4AddressCount")
    def ipv4_address_count(self) -> Optional[pulumi.Input[float]]:
        """
        The number of secondary private IPv4 addresses to assign to a network interface. Conflicts with `ipv4_addresses`
        """
        ...

    @ipv4_address_count.setter
    def ipv4_address_count(self, value: Optional[pulumi.Input[float]]):
        ...

    @property
    @pulumi.getter(name="ipv4Addresses")
    def ipv4_addresses(self) -> Optional[pulumi.Input[List[pulumi.Input[str]]]]:
        """
        One or more private IPv4 addresses to associate. Conflicts with `ipv4_address_count`
        """
        ...

    @ipv4_addresses.setter
    def ipv4_addresses(self, value: Optional[pulumi.Input[List[pulumi.Input[str]]]]):
        ...

    @property
    @pulumi.getter(name="ipv6AddressCount")
    def ipv6_address_count(self) -> Optional[pulumi.Input[float]]:
        """
        The number of IPv6 addresses to assign to a network interface. Conflicts with `ipv6_addresses`
        """
        ...

    @ipv6_address_count.setter
    def ipv6_address_count(self, value: Optional[pulumi.Input[float]]):
        ...

    @property
    @pulumi.getter(name="ipv6Addresses")
    def ipv6_addresses(self) -> Optional[pulumi.Input[List[pulumi.Input[str]]]]:
        """
        One or more specific IPv6 addresses from the IPv6 CIDR block range of your subnet. Conflicts with `ipv6_address_count`
        """
        ...

    @ipv6_addresses.setter
    def ipv6_addresses(self, value: Optional[pulumi.Input[List[pulumi.Input[str]]]]):
        ...

    @property
    @pulumi.getter(name="networkInterfaceId")
    def network_interface_id(self) -> Optional[pulumi.Input[str]]:
        """
        The ID of the network interface to attach.
        """
        ...

    @network_interface_id.setter
    def network_interface_id(self, value: Optional[pulumi.Input[str]]):
        ...

    @property
    @pulumi.getter(name="privateIpAddress")
    def private_ip_address(self) -> Optional[pulumi.Input[str]]:
        """
        The primary private IPv4 address.
        """
        ...

    @private_ip_address.setter
    def private_ip_address(self, value: Optional[pulumi.Input[str]]):
        ...

    @property
    @pulumi.getter(name="securityGroups")
    def security_groups(self) -> Optional[pulumi.Input[List[pulumi.Input[str]]]]:
        """
        A list of security group IDs to associate.
        """
        ...

    @security_groups.setter
    def security_groups(self, value: Optional[pulumi.Input[List[pulumi.Input[str]]]]):
        ...

    @property
    @pulumi.getter(name="subnetId")
    def subnet_id(self) -> Optional[pulumi.Input[str]]:
        """
        The VPC Subnet ID to associate.
        """
        ...

    @subnet_id.setter
    def subnet_id(self, value: Optional[pulumi.Input[str]]):
        ...


@pulumi.input_type
class LaunchTemplatePlacementArgs:
    def __init__(__self__, *,
                 affinity: Optional[pulumi.Input[str]] = None,
                 availability_zone: Optional[pulumi.Input[str]] = None,
                 group_name: Optional[pulumi.Input[str]] = None,
                 host_id: Optional[pulumi.Input[str]] = None,
                 partition_number: Optional[pulumi.Input[float]] = None,
                 spread_domain: Optional[pulumi.Input[str]] = None,
                 tenancy: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] affinity: The affinity setting for an instance on a Dedicated Host.
        :param pulumi.Input[str] availability_zone: The Availability Zone for the instance.
        :param pulumi.Input[str] group_name: The name of the placement group for the instance.
        :param pulumi.Input[str] host_id: The ID of the Dedicated Host for the instance.
        :param pulumi.Input[float] partition_number: The number of the partition the instance should launch in. Valid only if the placement group strategy is set to partition.
        :param pulumi.Input[str] spread_domain: Reserved for future use.
        :param pulumi.Input[str] tenancy: The tenancy of the instance (if the instance is running in a VPC). Can be `default`, `dedicated`, or `host`.
        """
        pulumi.set(__self__, "affinity", affinity)
        pulumi.set(__self__, "availabilityZone", availability_zone)
        pulumi.set(__self__, "groupName", group_name)
        pulumi.set(__self__, "hostId", host_id)
        pulumi.set(__self__, "partitionNumber", partition_number)
        pulumi.set(__self__, "spreadDomain", spread_domain)
        pulumi.set(__self__, "tenancy", tenancy)

    @property
    @pulumi.getter
    def affinity(self) -> Optional[pulumi.Input[str]]:
        """
        The affinity setting for an instance on a Dedicated Host.
        """
        ...

    @affinity.setter
    def affinity(self, value: Optional[pulumi.Input[str]]):
        ...

    @property
    @pulumi.getter(name="availabilityZone")
    def availability_zone(self) -> Optional[pulumi.Input[str]]:
        """
        The Availability Zone for the instance.
        """
        ...

    @availability_zone.setter
    def availability_zone(self, value: Optional[pulumi.Input[str]]):
        ...

    @property
    @pulumi.getter(name="groupName")
    def group_name(self) -> Optional[pulumi.Input[str]]:
        """
        The name of the placement group for the instance.
        """
        ...

    @group_name.setter
    def group_name(self, value: Optional[pulumi.Input[str]]):
        ...

    @property
    @pulumi.getter(name="hostId")
    def host_id(self) -> Optional[pulumi.Input[str]]:
        """
        The ID of the Dedicated Host for the instance.
        """
        ...

    @host_id.setter
    def host_id(self, value: Optional[pulumi.Input[str]]):
        ...

    @property
    @pulumi.getter(name="partitionNumber")
    def partition_number(self) -> Optional[pulumi.Input[float]]:
        """
        The number of the partition the instance should launch in. Valid only if the placement group strategy is set to partition.
        """
        ...

    @partition_number.setter
    def partition_number(self, value: Optional[pulumi.Input[float]]):
        ...

    @property
    @pulumi.getter(name="spreadDomain")
    def spread_domain(self) -> Optional[pulumi.Input[str]]:
        """
        Reserved for future use.
        """
        ...

    @spread_domain.setter
    def spread_domain(self, value: Optional[pulumi.Input[str]]):
        ...

    @property
    @pulumi.getter
    def tenancy(self) -> Optional[pulumi.Input[str]]:
        """
        The tenancy of the instance (if the instance is running in a VPC). Can be `default`, `dedicated`, or `host`.
        """
        ...

    @tenancy.setter
    def tenancy(self, value: Optional[pulumi.Input[str]]):
        ...


@pulumi.input_type
class LaunchTemplateTagSpecificationArgs:
    def __init__(__self__, *,
                 resource_type: Optional[pulumi.Input[str]] = None,
                 tags: Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]] = None):
        """
        :param pulumi.Input[str] resource_type: The type of resource to tag. Valid values are `instance` and `volume`.
        :param pulumi.Input[Mapping[str, pulumi.Input[str]]] tags: A map of tags to assign to the resource.
        """
        pulumi.set(__self__, "resourceType", resource_type)
        pulumi.set(__self__, "tags", tags)

    @property
    @pulumi.getter(name="resourceType")
    def resource_type(self) -> Optional[pulumi.Input[str]]:
        """
        The type of resource to tag. Valid values are `instance` and `volume`.
        """
        ...

    @resource_type.setter
    def resource_type(self, value: Optional[pulumi.Input[str]]):
        ...

    @property
    @pulumi.getter
    def tags(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]]:
        """
        A map of tags to assign to the resource.
        """
        ...

    @tags.setter
    def tags(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]]):
        ...


@pulumi.input_type
class NetworkAclEgressArgs:
    def __init__(__self__, *,
                 action: pulumi.Input[str],
                 from_port: pulumi.Input[float],
                 protocol: pulumi.Input[str],
                 rule_no: pulumi.Input[float],
                 to_port: pulumi.Input[float],
                 cidr_block: Optional[pulumi.Input[str]] = None,
                 icmp_code: Optional[pulumi.Input[float]] = None,
                 icmp_type: Optional[pulumi.Input[float]] = None,
                 ipv6_cidr_block: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] action: The action to take.
        :param pulumi.Input[float] from_port: The from port to match.
        :param pulumi.Input[str] protocol: The protocol to match. If using the -1 'all'
               protocol, you must specify a from and to port of 0.
        :param pulumi.Input[float] rule_no: The rule number. Used for ordering.
        :param pulumi.Input[float] to_port: The to port to match.
        :param pulumi.Input[str] cidr_block: The CIDR block to match. This must be a
               valid network mask.
        :param pulumi.Input[float] icmp_code: The ICMP type code to be used. Default 0.
        :param pulumi.Input[float] icmp_type: The ICMP type to be used. Default 0.
        :param pulumi.Input[str] ipv6_cidr_block: The IPv6 CIDR block.
        """
        pulumi.set(__self__, "action", action)
        pulumi.set(__self__, "fromPort", from_port)
        pulumi.set(__self__, "protocol", protocol)
        pulumi.set(__self__, "ruleNo", rule_no)
        pulumi.set(__self__, "toPort", to_port)
        pulumi.set(__self__, "cidrBlock", cidr_block)
        pulumi.set(__self__, "icmpCode", icmp_code)
        pulumi.set(__self__, "icmpType", icmp_type)
        pulumi.set(__self__, "ipv6CidrBlock", ipv6_cidr_block)

    @property
    @pulumi.getter
    def action(self) -> pulumi.Input[str]:
        """
        The action to take.
        """
        ...

    @action.setter
    def action(self, value: pulumi.Input[str]):
        ...

    @property
    @pulumi.getter(name="fromPort")
    def from_port(self) -> pulumi.Input[float]:
        """
        The from port to match.
        """
        ...

    @from_port.setter
    def from_port(self, value: pulumi.Input[float]):
        ...

    @property
    @pulumi.getter
    def protocol(self) -> pulumi.Input[str]:
        """
        The protocol to match. If using the -1 'all'
        protocol, you must specify a from and to port of 0.
        """
        ...

    @protocol.setter
    def protocol(self, value: pulumi.Input[str]):
        ...

    @property
    @pulumi.getter(name="ruleNo")
    def rule_no(self) -> pulumi.Input[float]:
        """
        The rule number. Used for ordering.
        """
        ...

    @rule_no.setter
    def rule_no(self, value: pulumi.Input[float]):
        ...

    @property
    @pulumi.getter(name="toPort")
    def to_port(self) -> pulumi.Input[float]:
        """
        The to port to match.
        """
        ...

    @to_port.setter
    def to_port(self, value: pulumi.Input[float]):
        ...

    @property
    @pulumi.getter(name="cidrBlock")
    def cidr_block(self) -> Optional[pulumi.Input[str]]:
        """
        The CIDR block to match. This must be a
        valid network mask.
        """
        ...

    @cidr_block.setter
    def cidr_block(self, value: Optional[pulumi.Input[str]]):
        ...

    @property
    @pulumi.getter(name="icmpCode")
    def icmp_code(self) -> Optional[pulumi.Input[float]]:
        """
        The ICMP type code to be used. Default 0.
        """
        ...

    @icmp_code.setter
    def icmp_code(self, value: Optional[pulumi.Input[float]]):
        ...

    @property
    @pulumi.getter(name="icmpType")
    def icmp_type(self) -> Optional[pulumi.Input[float]]:
        """
        The ICMP type to be used. Default 0.
        """
        ...

    @icmp_type.setter
    def icmp_type(self, value: Optional[pulumi.Input[float]]):
        ...

    @property
    @pulumi.getter(name="ipv6CidrBlock")
    def ipv6_cidr_block(self) -> Optional[pulumi.Input[str]]:
        """
        The IPv6 CIDR block.
        """
        ...

    @ipv6_cidr_block.setter
    def ipv6_cidr_block(self, value: Optional[pulumi.Input[str]]):
        ...


@pulumi.input_type
class NetworkAclIngressArgs:
    def __init__(__self__, *,
                 action: pulumi.Input[str],
                 from_port: pulumi.Input[float],
                 protocol: pulumi.Input[str],
                 rule_no: pulumi.Input[float],
                 to_port: pulumi.Input[float],
                 cidr_block: Optional[pulumi.Input[str]] = None,
                 icmp_code: Optional[pulumi.Input[float]] = None,
                 icmp_type: Optional[pulumi.Input[float]] = None,
                 ipv6_cidr_block: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] action: The action to take.
        :param pulumi.Input[float] from_port: The from port to match.
        :param pulumi.Input[str] protocol: The protocol to match. If using the -1 'all'
               protocol, you must specify a from and to port of 0.
        :param pulumi.Input[float] rule_no: The rule number. Used for ordering.
        :param pulumi.Input[float] to_port: The to port to match.
        :param pulumi.Input[str] cidr_block: The CIDR block to match. This must be a
               valid network mask.
        :param pulumi.Input[float] icmp_code: The ICMP type code to be used. Default 0.
        :param pulumi.Input[float] icmp_type: The ICMP type to be used. Default 0.
        :param pulumi.Input[str] ipv6_cidr_block: The IPv6 CIDR block.
        """
        pulumi.set(__self__, "action", action)
        pulumi.set(__self__, "fromPort", from_port)
        pulumi.set(__self__, "protocol", protocol)
        pulumi.set(__self__, "ruleNo", rule_no)
        pulumi.set(__self__, "toPort", to_port)
        pulumi.set(__self__, "cidrBlock", cidr_block)
        pulumi.set(__self__, "icmpCode", icmp_code)
        pulumi.set(__self__, "icmpType", icmp_type)
        pulumi.set(__self__, "ipv6CidrBlock", ipv6_cidr_block)

    @property
    @pulumi.getter
    def action(self) -> pulumi.Input[str]:
        """
        The action to take.
        """
        ...

    @action.setter
    def action(self, value: pulumi.Input[str]):
        ...

    @property
    @pulumi.getter(name="fromPort")
    def from_port(self) -> pulumi.Input[float]:
        """
        The from port to match.
        """
        ...

    @from_port.setter
    def from_port(self, value: pulumi.Input[float]):
        ...

    @property
    @pulumi.getter
    def protocol(self) -> pulumi.Input[str]:
        """
        The protocol to match. If using the -1 'all'
        protocol, you must specify a from and to port of 0.
        """
        ...

    @protocol.setter
    def protocol(self, value: pulumi.Input[str]):
        ...

    @property
    @pulumi.getter(name="ruleNo")
    def rule_no(self) -> pulumi.Input[float]:
        """
        The rule number. Used for ordering.
        """
        ...

    @rule_no.setter
    def rule_no(self, value: pulumi.Input[float]):
        ...

    @property
    @pulumi.getter(name="toPort")
    def to_port(self) -> pulumi.Input[float]:
        """
        The to port to match.
        """
        ...

    @to_port.setter
    def to_port(self, value: pulumi.Input[float]):
        ...

    @property
    @pulumi.getter(name="cidrBlock")
    def cidr_block(self) -> Optional[pulumi.Input[str]]:
        """
        The CIDR block to match. This must be a
        valid network mask.
        """
        ...

    @cidr_block.setter
    def cidr_block(self, value: Optional[pulumi.Input[str]]):
        ...

    @property
    @pulumi.getter(name="icmpCode")
    def icmp_code(self) -> Optional[pulumi.Input[float]]:
        """
        The ICMP type code to be used. Default 0.
        """
        ...

    @icmp_code.setter
    def icmp_code(self, value: Optional[pulumi.Input[float]]):
        ...

    @property
    @pulumi.getter(name="icmpType")
    def icmp_type(self) -> Optional[pulumi.Input[float]]:
        """
        The ICMP type to be used. Default 0.
        """
        ...

    @icmp_type.setter
    def icmp_type(self, value: Optional[pulumi.Input[float]]):
        ...

    @property
    @pulumi.getter(name="ipv6CidrBlock")
    def ipv6_cidr_block(self) -> Optional[pulumi.Input[str]]:
        """
        The IPv6 CIDR block.
        """
        ...

    @ipv6_cidr_block.setter
    def ipv6_cidr_block(self, value: Optional[pulumi.Input[str]]):
        ...


@pulumi.input_type
class NetworkInterfaceAttachmentArgs:
    def __init__(__self__, *,
                 device_index: pulumi.Input[float],
                 instance: pulumi.Input[str],
                 attachment_id: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[float] device_index: Integer to define the devices index.
        :param pulumi.Input[str] instance: ID of the instance to attach to.
        """
        pulumi.set(__self__, "deviceIndex", device_index)
        pulumi.set(__self__, "instance", instance)
        pulumi.set(__self__, "attachmentId", attachment_id)

    @property
    @pulumi.getter(name="deviceIndex")
    def device_index(self) -> pulumi.Input[float]:
        """
        Integer to define the devices index.
        """
        ...

    @device_index.setter
    def device_index(self, value: pulumi.Input[float]):
        ...

    @property
    @pulumi.getter
    def instance(self) -> pulumi.Input[str]:
        """
        ID of the instance to attach to.
        """
        ...

    @instance.setter
    def instance(self, value: pulumi.Input[str]):
        ...

    @property
    @pulumi.getter(name="attachmentId")
    def attachment_id(self) -> Optional[pulumi.Input[str]]:
        ...

    @attachment_id.setter
    def attachment_id(self, value: Optional[pulumi.Input[str]]):
        ...


@pulumi.input_type
class PeeringConnectionOptionsAccepterArgs:
    def __init__(__self__, *,
                 allow_classic_link_to_remote_vpc: Optional[pulumi.Input[bool]] = None,
                 allow_remote_vpc_dns_resolution: Optional[pulumi.Input[bool]] = None,
                 allow_vpc_to_remote_classic_link: Optional[pulumi.Input[bool]] = None):
        """
        :param pulumi.Input[bool] allow_classic_link_to_remote_vpc: Allow a local linked EC2-Classic instance to communicate
               with instances in a peer VPC. This enables an outbound communication from the local ClassicLink connection
               to the remote VPC. This option is not supported for inter-region VPC peering.
        :param pulumi.Input[bool] allow_remote_vpc_dns_resolution: Allow a local VPC to resolve public DNS hostnames to
               private IP addresses when queried from instances in the peer VPC.
        :param pulumi.Input[bool] allow_vpc_to_remote_classic_link: Allow a local VPC to communicate with a linked EC2-Classic
               instance in a peer VPC. This enables an outbound communication from the local VPC to the remote ClassicLink
               connection. This option is not supported for inter-region VPC peering.
        """
        pulumi.set(__self__, "allowClassicLinkToRemoteVpc", allow_classic_link_to_remote_vpc)
        pulumi.set(__self__, "allowRemoteVpcDnsResolution", allow_remote_vpc_dns_resolution)
        pulumi.set(__self__, "allowVpcToRemoteClassicLink", allow_vpc_to_remote_classic_link)

    @property
    @pulumi.getter(name="allowClassicLinkToRemoteVpc")
    def allow_classic_link_to_remote_vpc(self) -> Optional[pulumi.Input[bool]]:
        """
        Allow a local linked EC2-Classic instance to communicate
        with instances in a peer VPC. This enables an outbound communication from the local ClassicLink connection
        to the remote VPC. This option is not supported for inter-region VPC peering.
        """
        ...

    @allow_classic_link_to_remote_vpc.setter
    def allow_classic_link_to_remote_vpc(self, value: Optional[pulumi.Input[bool]]):
        ...

    @property
    @pulumi.getter(name="allowRemoteVpcDnsResolution")
    def allow_remote_vpc_dns_resolution(self) -> Optional[pulumi.Input[bool]]:
        """
        Allow a local VPC to resolve public DNS hostnames to
        private IP addresses when queried from instances in the peer VPC.
        """
        ...

    @allow_remote_vpc_dns_resolution.setter
    def allow_remote_vpc_dns_resolution(self, value: Optional[pulumi.Input[bool]]):
        ...

    @property
    @pulumi.getter(name="allowVpcToRemoteClassicLink")
    def allow_vpc_to_remote_classic_link(self) -> Optional[pulumi.Input[bool]]:
        """
        Allow a local VPC to communicate with a linked EC2-Classic
        instance in a peer VPC. This enables an outbound communication from the local VPC to the remote ClassicLink
        connection. This option is not supported for inter-region VPC peering.
        """
        ...

    @allow_vpc_to_remote_classic_link.setter
    def allow_vpc_to_remote_classic_link(self, value: Optional[pulumi.Input[bool]]):
        ...


@pulumi.input_type
class PeeringConnectionOptionsRequesterArgs:
    def __init__(__self__, *,
                 allow_classic_link_to_remote_vpc: Optional[pulumi.Input[bool]] = None,
                 allow_remote_vpc_dns_resolution: Optional[pulumi.Input[bool]] = None,
                 allow_vpc_to_remote_classic_link: Optional[pulumi.Input[bool]] = None):
        """
        :param pulumi.Input[bool] allow_classic_link_to_remote_vpc: Allow a local linked EC2-Classic instance to communicate
               with instances in a peer VPC. This enables an outbound communication from the local ClassicLink connection
               to the remote VPC. This option is not supported for inter-region VPC peering.
        :param pulumi.Input[bool] allow_remote_vpc_dns_resolution: Allow a local VPC to resolve public DNS hostnames to
               private IP addresses when queried from instances in the peer VPC.
        :param pulumi.Input[bool] allow_vpc_to_remote_classic_link: Allow a local VPC to communicate with a linked EC2-Classic
               instance in a peer VPC. This enables an outbound communication from the local VPC to the remote ClassicLink
               connection. This option is not supported for inter-region VPC peering.
        """
        pulumi.set(__self__, "allowClassicLinkToRemoteVpc", allow_classic_link_to_remote_vpc)
        pulumi.set(__self__, "allowRemoteVpcDnsResolution", allow_remote_vpc_dns_resolution)
        pulumi.set(__self__, "allowVpcToRemoteClassicLink", allow_vpc_to_remote_classic_link)

    @property
    @pulumi.getter(name="allowClassicLinkToRemoteVpc")
    def allow_classic_link_to_remote_vpc(self) -> Optional[pulumi.Input[bool]]:
        """
        Allow a local linked EC2-Classic instance to communicate
        with instances in a peer VPC. This enables an outbound communication from the local ClassicLink connection
        to the remote VPC. This option is not supported for inter-region VPC peering.
        """
        ...

    @allow_classic_link_to_remote_vpc.setter
    def allow_classic_link_to_remote_vpc(self, value: Optional[pulumi.Input[bool]]):
        ...

    @property
    @pulumi.getter(name="allowRemoteVpcDnsResolution")
    def allow_remote_vpc_dns_resolution(self) -> Optional[pulumi.Input[bool]]:
        """
        Allow a local VPC to resolve public DNS hostnames to
        private IP addresses when queried from instances in the peer VPC.
        """
        ...

    @allow_remote_vpc_dns_resolution.setter
    def allow_remote_vpc_dns_resolution(self, value: Optional[pulumi.Input[bool]]):
        ...

    @property
    @pulumi.getter(name="allowVpcToRemoteClassicLink")
    def allow_vpc_to_remote_classic_link(self) -> Optional[pulumi.Input[bool]]:
        """
        Allow a local VPC to communicate with a linked EC2-Classic
        instance in a peer VPC. This enables an outbound communication from the local VPC to the remote ClassicLink
        connection. This option is not supported for inter-region VPC peering.
        """
        ...

    @allow_vpc_to_remote_classic_link.setter
    def allow_vpc_to_remote_classic_link(self, value: Optional[pulumi.Input[bool]]):
        ...


@pulumi.input_type
class RouteTableRouteArgs:
    def __init__(__self__, *,
                 cidr_block: Optional[pulumi.Input[str]] = None,
                 egress_only_gateway_id: Optional[pulumi.Input[str]] = None,
                 gateway_id: Optional[pulumi.Input[str]] = None,
                 instance_id: Optional[pulumi.Input[str]] = None,
                 ipv6_cidr_block: Optional[pulumi.Input[str]] = None,
                 nat_gateway_id: Optional[pulumi.Input[str]] = None,
                 network_interface_id: Optional[pulumi.Input[str]] = None,
                 transit_gateway_id: Optional[pulumi.Input[str]] = None,
                 vpc_peering_connection_id: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] cidr_block: The CIDR block of the route.
        :param pulumi.Input[str] egress_only_gateway_id: Identifier of a VPC Egress Only Internet Gateway.
        :param pulumi.Input[str] gateway_id: Identifier of a VPC internet gateway or a virtual private gateway.
        :param pulumi.Input[str] instance_id: Identifier of an EC2 instance.
        :param pulumi.Input[str] ipv6_cidr_block: The Ipv6 CIDR block of the route.
        :param pulumi.Input[str] nat_gateway_id: Identifier of a VPC NAT gateway.
        :param pulumi.Input[str] network_interface_id: Identifier of an EC2 network interface.
        :param pulumi.Input[str] transit_gateway_id: Identifier of an EC2 Transit Gateway.
        :param pulumi.Input[str] vpc_peering_connection_id: Identifier of a VPC peering connection.
        """
        pulumi.set(__self__, "cidrBlock", cidr_block)
        pulumi.set(__self__, "egressOnlyGatewayId", egress_only_gateway_id)
        pulumi.set(__self__, "gatewayId", gateway_id)
        pulumi.set(__self__, "instanceId", instance_id)
        pulumi.set(__self__, "ipv6CidrBlock", ipv6_cidr_block)
        pulumi.set(__self__, "natGatewayId", nat_gateway_id)
        pulumi.set(__self__, "networkInterfaceId", network_interface_id)
        pulumi.set(__self__, "transitGatewayId", transit_gateway_id)
        pulumi.set(__self__, "vpcPeeringConnectionId", vpc_peering_connection_id)

    @property
    @pulumi.getter(name="cidrBlock")
    def cidr_block(self) -> Optional[pulumi.Input[str]]:
        """
        The CIDR block of the route.
        """
        ...

    @cidr_block.setter
    def cidr_block(self, value: Optional[pulumi.Input[str]]):
        ...

    @property
    @pulumi.getter(name="egressOnlyGatewayId")
    def egress_only_gateway_id(self) -> Optional[pulumi.Input[str]]:
        """
        Identifier of a VPC Egress Only Internet Gateway.
        """
        ...

    @egress_only_gateway_id.setter
    def egress_only_gateway_id(self, value: Optional[pulumi.Input[str]]):
        ...

    @property
    @pulumi.getter(name="gatewayId")
    def gateway_id(self) -> Optional[pulumi.Input[str]]:
        """
        Identifier of a VPC internet gateway or a virtual private gateway.
        """
        ...

    @gateway_id.setter
    def gateway_id(self, value: Optional[pulumi.Input[str]]):
        ...

    @property
    @pulumi.getter(name="instanceId")
    def instance_id(self) -> Optional[pulumi.Input[str]]:
        """
        Identifier of an EC2 instance.
        """
        ...

    @instance_id.setter
    def instance_id(self, value: Optional[pulumi.Input[str]]):
        ...

    @property
    @pulumi.getter(name="ipv6CidrBlock")
    def ipv6_cidr_block(self) -> Optional[pulumi.Input[str]]:
        """
        The Ipv6 CIDR block of the route.
        """
        ...

    @ipv6_cidr_block.setter
    def ipv6_cidr_block(self, value: Optional[pulumi.Input[str]]):
        ...

    @property
    @pulumi.getter(name="natGatewayId")
    def nat_gateway_id(self) -> Optional[pulumi.Input[str]]:
        """
        Identifier of a VPC NAT gateway.
        """
        ...

    @nat_gateway_id.setter
    def nat_gateway_id(self, value: Optional[pulumi.Input[str]]):
        ...

    @property
    @pulumi.getter(name="networkInterfaceId")
    def network_interface_id(self) -> Optional[pulumi.Input[str]]:
        """
        Identifier of an EC2 network interface.
        """
        ...

    @network_interface_id.setter
    def network_interface_id(self, value: Optional[pulumi.Input[str]]):
        ...

    @property
    @pulumi.getter(name="transitGatewayId")
    def transit_gateway_id(self) -> Optional[pulumi.Input[str]]:
        """
        Identifier of an EC2 Transit Gateway.
        """
        ...

    @transit_gateway_id.setter
    def transit_gateway_id(self, value: Optional[pulumi.Input[str]]):
        ...

    @property
    @pulumi.getter(name="vpcPeeringConnectionId")
    def vpc_peering_connection_id(self) -> Optional[pulumi.Input[str]]:
        """
        Identifier of a VPC peering connection.
        """
        ...

    @vpc_peering_connection_id.setter
    def vpc_peering_connection_id(self, value: Optional[pulumi.Input[str]]):
        ...


@pulumi.input_type
class SecurityGroupEgressArgs:
    def __init__(__self__, *,
                 from_port: pulumi.Input[float],
                 protocol: pulumi.Input[str],
                 to_port: pulumi.Input[float],
                 cidr_blocks: Optional[pulumi.Input[List[pulumi.Input[str]]]] = None,
                 description: Optional[pulumi.Input[str]] = None,
                 ipv6_cidr_blocks: Optional[pulumi.Input[List[pulumi.Input[str]]]] = None,
                 prefix_list_ids: Optional[pulumi.Input[List[pulumi.Input[str]]]] = None,
                 security_groups: Optional[pulumi.Input[List[pulumi.Input[str]]]] = None,
                 self: Optional[pulumi.Input[bool]] = None):
        """
        :param pulumi.Input[float] from_port: The start port (or ICMP type number if protocol is "icmp")
        :param pulumi.Input[str] protocol: The protocol. If you select a protocol of
               "-1" (semantically equivalent to `"all"`, which is not a valid value here), you must specify a "from_port" and "to_port" equal to 0. If not icmp, tcp, udp, or "-1" use the [protocol number](https://www.iana.org/assignments/protocol-numbers/protocol-numbers.xhtml)
        :param pulumi.Input[float] to_port: The end range port (or ICMP code if protocol is "icmp").
        :param pulumi.Input[List[pulumi.Input[str]]] cidr_blocks: List of CIDR blocks.
        :param pulumi.Input[str] description: Description of this egress rule.
        :param pulumi.Input[List[pulumi.Input[str]]] ipv6_cidr_blocks: List of IPv6 CIDR blocks.
        :param pulumi.Input[List[pulumi.Input[str]]] prefix_list_ids: List of prefix list IDs (for allowing access to VPC endpoints)
        :param pulumi.Input[List[pulumi.Input[str]]] security_groups: List of security group Group Names if using
               EC2-Classic, or Group IDs if using a VPC.
        :param pulumi.Input[bool] self: If true, the security group itself will be added as
               a source to this egress rule.
        """
        pulumi.set(__self__, "fromPort", from_port)
        pulumi.set(__self__, "protocol", protocol)
        pulumi.set(__self__, "toPort", to_port)
        pulumi.set(__self__, "cidrBlocks", cidr_blocks)
        pulumi.set(__self__, "description", description)
        pulumi.set(__self__, "ipv6CidrBlocks", ipv6_cidr_blocks)
        pulumi.set(__self__, "prefixListIds", prefix_list_ids)
        pulumi.set(__self__, "securityGroups", security_groups)
        pulumi.set(__self__, "self", self)

    @property
    @pulumi.getter(name="fromPort")
    def from_port(self) -> pulumi.Input[float]:
        """
        The start port (or ICMP type number if protocol is "icmp")
        """
        ...

    @from_port.setter
    def from_port(self, value: pulumi.Input[float]):
        ...

    @property
    @pulumi.getter
    def protocol(self) -> pulumi.Input[str]:
        """
        The protocol. If you select a protocol of
        "-1" (semantically equivalent to `"all"`, which is not a valid value here), you must specify a "from_port" and "to_port" equal to 0. If not icmp, tcp, udp, or "-1" use the [protocol number](https://www.iana.org/assignments/protocol-numbers/protocol-numbers.xhtml)
        """
        ...

    @protocol.setter
    def protocol(self, value: pulumi.Input[str]):
        ...

    @property
    @pulumi.getter(name="toPort")
    def to_port(self) -> pulumi.Input[float]:
        """
        The end range port (or ICMP code if protocol is "icmp").
        """
        ...

    @to_port.setter
    def to_port(self, value: pulumi.Input[float]):
        ...

    @property
    @pulumi.getter(name="cidrBlocks")
    def cidr_blocks(self) -> Optional[pulumi.Input[List[pulumi.Input[str]]]]:
        """
        List of CIDR blocks.
        """
        ...

    @cidr_blocks.setter
    def cidr_blocks(self, value: Optional[pulumi.Input[List[pulumi.Input[str]]]]):
        ...

    @property
    @pulumi.getter
    def description(self) -> Optional[pulumi.Input[str]]:
        """
        Description of this egress rule.
        """
        ...

    @description.setter
    def description(self, value: Optional[pulumi.Input[str]]):
        ...

    @property
    @pulumi.getter(name="ipv6CidrBlocks")
    def ipv6_cidr_blocks(self) -> Optional[pulumi.Input[List[pulumi.Input[str]]]]:
        """
        List of IPv6 CIDR blocks.
        """
        ...

    @ipv6_cidr_blocks.setter
    def ipv6_cidr_blocks(self, value: Optional[pulumi.Input[List[pulumi.Input[str]]]]):
        ...

    @property
    @pulumi.getter(name="prefixListIds")
    def prefix_list_ids(self) -> Optional[pulumi.Input[List[pulumi.Input[str]]]]:
        """
        List of prefix list IDs (for allowing access to VPC endpoints)
        """
        ...

    @prefix_list_ids.setter
    def prefix_list_ids(self, value: Optional[pulumi.Input[List[pulumi.Input[str]]]]):
        ...

    @property
    @pulumi.getter(name="securityGroups")
    def security_groups(self) -> Optional[pulumi.Input[List[pulumi.Input[str]]]]:
        """
        List of security group Group Names if using
        EC2-Classic, or Group IDs if using a VPC.
        """
        ...

    @security_groups.setter
    def security_groups(self, value: Optional[pulumi.Input[List[pulumi.Input[str]]]]):
        ...

    @property
    @pulumi.getter
    def self(self) -> Optional[pulumi.Input[bool]]:
        """
        If true, the security group itself will be added as
        a source to this egress rule.
        """
        ...

    @self.setter
    def self(self, value: Optional[pulumi.Input[bool]]):
        ...


@pulumi.input_type
class SecurityGroupIngressArgs:
    def __init__(__self__, *,
                 from_port: pulumi.Input[float],
                 protocol: pulumi.Input[str],
                 to_port: pulumi.Input[float],
                 cidr_blocks: Optional[pulumi.Input[List[pulumi.Input[str]]]] = None,
                 description: Optional[pulumi.Input[str]] = None,
                 ipv6_cidr_blocks: Optional[pulumi.Input[List[pulumi.Input[str]]]] = None,
                 prefix_list_ids: Optional[pulumi.Input[List[pulumi.Input[str]]]] = None,
                 security_groups: Optional[pulumi.Input[List[pulumi.Input[str]]]] = None,
                 self: Optional[pulumi.Input[bool]] = None):
        """
        :param pulumi.Input[float] from_port: The start port (or ICMP type number if protocol is "icmp")
        :param pulumi.Input[str] protocol: The protocol. If you select a protocol of
               "-1" (semantically equivalent to `"all"`, which is not a valid value here), you must specify a "from_port" and "to_port" equal to 0. If not icmp, tcp, udp, or "-1" use the [protocol number](https://www.iana.org/assignments/protocol-numbers/protocol-numbers.xhtml)
        :param pulumi.Input[float] to_port: The end range port (or ICMP code if protocol is "icmp").
        :param pulumi.Input[List[pulumi.Input[str]]] cidr_blocks: List of CIDR blocks.
        :param pulumi.Input[str] description: Description of this egress rule.
        :param pulumi.Input[List[pulumi.Input[str]]] ipv6_cidr_blocks: List of IPv6 CIDR blocks.
        :param pulumi.Input[List[pulumi.Input[str]]] prefix_list_ids: List of prefix list IDs (for allowing access to VPC endpoints)
        :param pulumi.Input[List[pulumi.Input[str]]] security_groups: List of security group Group Names if using
               EC2-Classic, or Group IDs if using a VPC.
        :param pulumi.Input[bool] self: If true, the security group itself will be added as
               a source to this egress rule.
        """
        pulumi.set(__self__, "fromPort", from_port)
        pulumi.set(__self__, "protocol", protocol)
        pulumi.set(__self__, "toPort", to_port)
        pulumi.set(__self__, "cidrBlocks", cidr_blocks)
        pulumi.set(__self__, "description", description)
        pulumi.set(__self__, "ipv6CidrBlocks", ipv6_cidr_blocks)
        pulumi.set(__self__, "prefixListIds", prefix_list_ids)
        pulumi.set(__self__, "securityGroups", security_groups)
        pulumi.set(__self__, "self", self)

    @property
    @pulumi.getter(name="fromPort")
    def from_port(self) -> pulumi.Input[float]:
        """
        The start port (or ICMP type number if protocol is "icmp")
        """
        ...

    @from_port.setter
    def from_port(self, value: pulumi.Input[float]):
        ...

    @property
    @pulumi.getter
    def protocol(self) -> pulumi.Input[str]:
        """
        The protocol. If you select a protocol of
        "-1" (semantically equivalent to `"all"`, which is not a valid value here), you must specify a "from_port" and "to_port" equal to 0. If not icmp, tcp, udp, or "-1" use the [protocol number](https://www.iana.org/assignments/protocol-numbers/protocol-numbers.xhtml)
        """
        ...

    @protocol.setter
    def protocol(self, value: pulumi.Input[str]):
        ...

    @property
    @pulumi.getter(name="toPort")
    def to_port(self) -> pulumi.Input[float]:
        """
        The end range port (or ICMP code if protocol is "icmp").
        """
        ...

    @to_port.setter
    def to_port(self, value: pulumi.Input[float]):
        ...

    @property
    @pulumi.getter(name="cidrBlocks")
    def cidr_blocks(self) -> Optional[pulumi.Input[List[pulumi.Input[str]]]]:
        """
        List of CIDR blocks.
        """
        ...

    @cidr_blocks.setter
    def cidr_blocks(self, value: Optional[pulumi.Input[List[pulumi.Input[str]]]]):
        ...

    @property
    @pulumi.getter
    def description(self) -> Optional[pulumi.Input[str]]:
        """
        Description of this egress rule.
        """
        ...

    @description.setter
    def description(self, value: Optional[pulumi.Input[str]]):
        ...

    @property
    @pulumi.getter(name="ipv6CidrBlocks")
    def ipv6_cidr_blocks(self) -> Optional[pulumi.Input[List[pulumi.Input[str]]]]:
        """
        List of IPv6 CIDR blocks.
        """
        ...

    @ipv6_cidr_blocks.setter
    def ipv6_cidr_blocks(self, value: Optional[pulumi.Input[List[pulumi.Input[str]]]]):
        ...

    @property
    @pulumi.getter(name="prefixListIds")
    def prefix_list_ids(self) -> Optional[pulumi.Input[List[pulumi.Input[str]]]]:
        """
        List of prefix list IDs (for allowing access to VPC endpoints)
        """
        ...

    @prefix_list_ids.setter
    def prefix_list_ids(self, value: Optional[pulumi.Input[List[pulumi.Input[str]]]]):
        ...

    @property
    @pulumi.getter(name="securityGroups")
    def security_groups(self) -> Optional[pulumi.Input[List[pulumi.Input[str]]]]:
        """
        List of security group Group Names if using
        EC2-Classic, or Group IDs if using a VPC.
        """
        ...

    @security_groups.setter
    def security_groups(self, value: Optional[pulumi.Input[List[pulumi.Input[str]]]]):
        ...

    @property
    @pulumi.getter
    def self(self) -> Optional[pulumi.Input[bool]]:
        """
        If true, the security group itself will be added as
        a source to this egress rule.
        """
        ...

    @self.setter
    def self(self, value: Optional[pulumi.Input[bool]]):
        ...


@pulumi.input_type
class SpotFleetRequestLaunchSpecificationArgs:
    def __init__(__self__, *,
                 ami: pulumi.Input[str],
                 instance_type: pulumi.Input[str],
                 associate_public_ip_address: Optional[pulumi.Input[bool]] = None,
                 availability_zone: Optional[pulumi.Input[str]] = None,
                 ebs_block_devices: Optional[pulumi.Input[List[pulumi.Input['SpotFleetRequestLaunchSpecificationEbsBlockDeviceArgs']]]] = None,
                 ebs_optimized: Optional[pulumi.Input[bool]] = None,
                 ephemeral_block_devices: Optional[pulumi.Input[List[pulumi.Input['SpotFleetRequestLaunchSpecificationEphemeralBlockDeviceArgs']]]] = None,
                 iam_instance_profile: Optional[pulumi.Input[str]] = None,
                 iam_instance_profile_arn: Optional[pulumi.Input[str]] = None,
                 key_name: Optional[pulumi.Input[str]] = None,
                 monitoring: Optional[pulumi.Input[bool]] = None,
                 placement_group: Optional[pulumi.Input[str]] = None,
                 placement_tenancy: Optional[pulumi.Input[str]] = None,
                 root_block_devices: Optional[pulumi.Input[List[pulumi.Input['SpotFleetRequestLaunchSpecificationRootBlockDeviceArgs']]]] = None,
                 spot_price: Optional[pulumi.Input[str]] = None,
                 subnet_id: Optional[pulumi.Input[str]] = None,
                 tags: Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]] = None,
                 user_data: Optional[pulumi.Input[str]] = None,
                 vpc_security_group_ids: Optional[pulumi.Input[List[pulumi.Input[str]]]] = None,
                 weighted_capacity: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] instance_type: The type of instance to request.
        :param pulumi.Input[str] availability_zone: The availability zone in which to place the request.
        :param pulumi.Input[str] spot_price: The maximum spot bid for this override request.
        :param pulumi.Input[str] subnet_id: The subnet in which to launch the requested instance.
        :param pulumi.Input[Mapping[str, pulumi.Input[str]]] tags: A map of tags to assign to the resource.
        :param pulumi.Input[str] weighted_capacity: The capacity added to the fleet by a fulfilled request.
        """
        pulumi.set(__self__, "ami", ami)
        pulumi.set(__self__, "instanceType", instance_type)
        pulumi.set(__self__, "associatePublicIpAddress", associate_public_ip_address)
        pulumi.set(__self__, "availabilityZone", availability_zone)
        pulumi.set(__self__, "ebsBlockDevices", ebs_block_devices)
        pulumi.set(__self__, "ebsOptimized", ebs_optimized)
        pulumi.set(__self__, "ephemeralBlockDevices", ephemeral_block_devices)
        pulumi.set(__self__, "iamInstanceProfile", iam_instance_profile)
        pulumi.set(__self__, "iamInstanceProfileArn", iam_instance_profile_arn)
        pulumi.set(__self__, "keyName", key_name)
        pulumi.set(__self__, "monitoring", monitoring)
        pulumi.set(__self__, "placementGroup", placement_group)
        pulumi.set(__self__, "placementTenancy", placement_tenancy)
        pulumi.set(__self__, "rootBlockDevices", root_block_devices)
        pulumi.set(__self__, "spotPrice", spot_price)
        pulumi.set(__self__, "subnetId", subnet_id)
        pulumi.set(__self__, "tags", tags)
        pulumi.set(__self__, "userData", user_data)
        pulumi.set(__self__, "vpcSecurityGroupIds", vpc_security_group_ids)
        pulumi.set(__self__, "weightedCapacity", weighted_capacity)

    @property
    @pulumi.getter
    def ami(self) -> pulumi.Input[str]:
        ...

    @ami.setter
    def ami(self, value: pulumi.Input[str]):
        ...

    @property
    @pulumi.getter(name="instanceType")
    def instance_type(self) -> pulumi.Input[str]:
        """
        The type of instance to request.
        """
        ...

    @instance_type.setter
    def instance_type(self, value: pulumi.Input[str]):
        ...

    @property
    @pulumi.getter(name="associatePublicIpAddress")
    def associate_public_ip_address(self) -> Optional[pulumi.Input[bool]]:
        ...

    @associate_public_ip_address.setter
    def associate_public_ip_address(self, value: Optional[pulumi.Input[bool]]):
        ...

    @property
    @pulumi.getter(name="availabilityZone")
    def availability_zone(self) -> Optional[pulumi.Input[str]]:
        """
        The availability zone in which to place the request.
        """
        ...

    @availability_zone.setter
    def availability_zone(self, value: Optional[pulumi.Input[str]]):
        ...

    @property
    @pulumi.getter(name="ebsBlockDevices")
    def ebs_block_devices(self) -> Optional[pulumi.Input[List[pulumi.Input['SpotFleetRequestLaunchSpecificationEbsBlockDeviceArgs']]]]:
        ...

    @ebs_block_devices.setter
    def ebs_block_devices(self, value: Optional[pulumi.Input[List[pulumi.Input['SpotFleetRequestLaunchSpecificationEbsBlockDeviceArgs']]]]):
        ...

    @property
    @pulumi.getter(name="ebsOptimized")
    def ebs_optimized(self) -> Optional[pulumi.Input[bool]]:
        ...

    @ebs_optimized.setter
    def ebs_optimized(self, value: Optional[pulumi.Input[bool]]):
        ...

    @property
    @pulumi.getter(name="ephemeralBlockDevices")
    def ephemeral_block_devices(self) -> Optional[pulumi.Input[List[pulumi.Input['SpotFleetRequestLaunchSpecificationEphemeralBlockDeviceArgs']]]]:
        ...

    @ephemeral_block_devices.setter
    def ephemeral_block_devices(self, value: Optional[pulumi.Input[List[pulumi.Input['SpotFleetRequestLaunchSpecificationEphemeralBlockDeviceArgs']]]]):
        ...

    @property
    @pulumi.getter(name="iamInstanceProfile")
    def iam_instance_profile(self) -> Optional[pulumi.Input[str]]:
        ...

    @iam_instance_profile.setter
    def iam_instance_profile(self, value: Optional[pulumi.Input[str]]):
        ...

    @property
    @pulumi.getter(name="iamInstanceProfileArn")
    def iam_instance_profile_arn(self) -> Optional[pulumi.Input[str]]:
        ...

    @iam_instance_profile_arn.setter
    def iam_instance_profile_arn(self, value: Optional[pulumi.Input[str]]):
        ...

    @property
    @pulumi.getter(name="keyName")
    def key_name(self) -> Optional[pulumi.Input[str]]:
        ...

    @key_name.setter
    def key_name(self, value: Optional[pulumi.Input[str]]):
        ...

    @property
    @pulumi.getter
    def monitoring(self) -> Optional[pulumi.Input[bool]]:
        ...

    @monitoring.setter
    def monitoring(self, value: Optional[pulumi.Input[bool]]):
        ...

    @property
    @pulumi.getter(name="placementGroup")
    def placement_group(self) -> Optional[pulumi.Input[str]]:
        ...

    @placement_group.setter
    def placement_group(self, value: Optional[pulumi.Input[str]]):
        ...

    @property
    @pulumi.getter(name="placementTenancy")
    def placement_tenancy(self) -> Optional[pulumi.Input[str]]:
        ...

    @placement_tenancy.setter
    def placement_tenancy(self, value: Optional[pulumi.Input[str]]):
        ...

    @property
    @pulumi.getter(name="rootBlockDevices")
    def root_block_devices(self) -> Optional[pulumi.Input[List[pulumi.Input['SpotFleetRequestLaunchSpecificationRootBlockDeviceArgs']]]]:
        ...

    @root_block_devices.setter
    def root_block_devices(self, value: Optional[pulumi.Input[List[pulumi.Input['SpotFleetRequestLaunchSpecificationRootBlockDeviceArgs']]]]):
        ...

    @property
    @pulumi.getter(name="spotPrice")
    def spot_price(self) -> Optional[pulumi.Input[str]]:
        """
        The maximum spot bid for this override request.
        """
        ...

    @spot_price.setter
    def spot_price(self, value: Optional[pulumi.Input[str]]):
        ...

    @property
    @pulumi.getter(name="subnetId")
    def subnet_id(self) -> Optional[pulumi.Input[str]]:
        """
        The subnet in which to launch the requested instance.
        """
        ...

    @subnet_id.setter
    def subnet_id(self, value: Optional[pulumi.Input[str]]):
        ...

    @property
    @pulumi.getter
    def tags(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]]:
        """
        A map of tags to assign to the resource.
        """
        ...

    @tags.setter
    def tags(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]]):
        ...

    @property
    @pulumi.getter(name="userData")
    def user_data(self) -> Optional[pulumi.Input[str]]:
        ...

    @user_data.setter
    def user_data(self, value: Optional[pulumi.Input[str]]):
        ...

    @property
    @pulumi.getter(name="vpcSecurityGroupIds")
    def vpc_security_group_ids(self) -> Optional[pulumi.Input[List[pulumi.Input[str]]]]:
        ...

    @vpc_security_group_ids.setter
    def vpc_security_group_ids(self, value: Optional[pulumi.Input[List[pulumi.Input[str]]]]):
        ...

    @property
    @pulumi.getter(name="weightedCapacity")
    def weighted_capacity(self) -> Optional[pulumi.Input[str]]:
        """
        The capacity added to the fleet by a fulfilled request.
        """
        ...

    @weighted_capacity.setter
    def weighted_capacity(self, value: Optional[pulumi.Input[str]]):
        ...


@pulumi.input_type
class SpotFleetRequestLaunchSpecificationEbsBlockDeviceArgs:
    def __init__(__self__, *,
                 device_name: pulumi.Input[str],
                 delete_on_termination: Optional[pulumi.Input[bool]] = None,
                 encrypted: Optional[pulumi.Input[bool]] = None,
                 iops: Optional[pulumi.Input[float]] = None,
                 kms_key_id: Optional[pulumi.Input[str]] = None,
                 snapshot_id: Optional[pulumi.Input[str]] = None,
                 volume_size: Optional[pulumi.Input[float]] = None,
                 volume_type: Optional[pulumi.Input[str]] = None):
        pulumi.set(__self__, "deviceName", device_name)
        pulumi.set(__self__, "deleteOnTermination", delete_on_termination)
        pulumi.set(__self__, "encrypted", encrypted)
        pulumi.set(__self__, "iops", iops)
        pulumi.set(__self__, "kmsKeyId", kms_key_id)
        pulumi.set(__self__, "snapshotId", snapshot_id)
        pulumi.set(__self__, "volumeSize", volume_size)
        pulumi.set(__self__, "volumeType", volume_type)

    @property
    @pulumi.getter(name="deviceName")
    def device_name(self) -> pulumi.Input[str]:
        ...

    @device_name.setter
    def device_name(self, value: pulumi.Input[str]):
        ...

    @property
    @pulumi.getter(name="deleteOnTermination")
    def delete_on_termination(self) -> Optional[pulumi.Input[bool]]:
        ...

    @delete_on_termination.setter
    def delete_on_termination(self, value: Optional[pulumi.Input[bool]]):
        ...

    @property
    @pulumi.getter
    def encrypted(self) -> Optional[pulumi.Input[bool]]:
        ...

    @encrypted.setter
    def encrypted(self, value: Optional[pulumi.Input[bool]]):
        ...

    @property
    @pulumi.getter
    def iops(self) -> Optional[pulumi.Input[float]]:
        ...

    @iops.setter
    def iops(self, value: Optional[pulumi.Input[float]]):
        ...

    @property
    @pulumi.getter(name="kmsKeyId")
    def kms_key_id(self) -> Optional[pulumi.Input[str]]:
        ...

    @kms_key_id.setter
    def kms_key_id(self, value: Optional[pulumi.Input[str]]):
        ...

    @property
    @pulumi.getter(name="snapshotId")
    def snapshot_id(self) -> Optional[pulumi.Input[str]]:
        ...

    @snapshot_id.setter
    def snapshot_id(self, value: Optional[pulumi.Input[str]]):
        ...

    @property
    @pulumi.getter(name="volumeSize")
    def volume_size(self) -> Optional[pulumi.Input[float]]:
        ...

    @volume_size.setter
    def volume_size(self, value: Optional[pulumi.Input[float]]):
        ...

    @property
    @pulumi.getter(name="volumeType")
    def volume_type(self) -> Optional[pulumi.Input[str]]:
        ...

    @volume_type.setter
    def volume_type(self, value: Optional[pulumi.Input[str]]):
        ...


@pulumi.input_type
class SpotFleetRequestLaunchSpecificationEphemeralBlockDeviceArgs:
    def __init__(__self__, *,
                 device_name: pulumi.Input[str],
                 virtual_name: pulumi.Input[str]):
        pulumi.set(__self__, "deviceName", device_name)
        pulumi.set(__self__, "virtualName", virtual_name)

    @property
    @pulumi.getter(name="deviceName")
    def device_name(self) -> pulumi.Input[str]:
        ...

    @device_name.setter
    def device_name(self, value: pulumi.Input[str]):
        ...

    @property
    @pulumi.getter(name="virtualName")
    def virtual_name(self) -> pulumi.Input[str]:
        ...

    @virtual_name.setter
    def virtual_name(self, value: pulumi.Input[str]):
        ...


@pulumi.input_type
class SpotFleetRequestLaunchSpecificationRootBlockDeviceArgs:
    def __init__(__self__, *,
                 delete_on_termination: Optional[pulumi.Input[bool]] = None,
                 encrypted: Optional[pulumi.Input[bool]] = None,
                 iops: Optional[pulumi.Input[float]] = None,
                 kms_key_id: Optional[pulumi.Input[str]] = None,
                 volume_size: Optional[pulumi.Input[float]] = None,
                 volume_type: Optional[pulumi.Input[str]] = None):
        pulumi.set(__self__, "deleteOnTermination", delete_on_termination)
        pulumi.set(__self__, "encrypted", encrypted)
        pulumi.set(__self__, "iops", iops)
        pulumi.set(__self__, "kmsKeyId", kms_key_id)
        pulumi.set(__self__, "volumeSize", volume_size)
        pulumi.set(__self__, "volumeType", volume_type)

    @property
    @pulumi.getter(name="deleteOnTermination")
    def delete_on_termination(self) -> Optional[pulumi.Input[bool]]:
        ...

    @delete_on_termination.setter
    def delete_on_termination(self, value: Optional[pulumi.Input[bool]]):
        ...

    @property
    @pulumi.getter
    def encrypted(self) -> Optional[pulumi.Input[bool]]:
        ...

    @encrypted.setter
    def encrypted(self, value: Optional[pulumi.Input[bool]]):
        ...

    @property
    @pulumi.getter
    def iops(self) -> Optional[pulumi.Input[float]]:
        ...

    @iops.setter
    def iops(self, value: Optional[pulumi.Input[float]]):
        ...

    @property
    @pulumi.getter(name="kmsKeyId")
    def kms_key_id(self) -> Optional[pulumi.Input[str]]:
        ...

    @kms_key_id.setter
    def kms_key_id(self, value: Optional[pulumi.Input[str]]):
        ...

    @property
    @pulumi.getter(name="volumeSize")
    def volume_size(self) -> Optional[pulumi.Input[float]]:
        ...

    @volume_size.setter
    def volume_size(self, value: Optional[pulumi.Input[float]]):
        ...

    @property
    @pulumi.getter(name="volumeType")
    def volume_type(self) -> Optional[pulumi.Input[str]]:
        ...

    @volume_type.setter
    def volume_type(self, value: Optional[pulumi.Input[str]]):
        ...


@pulumi.input_type
class SpotFleetRequestLaunchTemplateConfigArgs:
    def __init__(__self__, *,
                 launch_template_specification: pulumi.Input['SpotFleetRequestLaunchTemplateConfigLaunchTemplateSpecificationArgs'],
                 overrides: Optional[pulumi.Input[List[pulumi.Input['SpotFleetRequestLaunchTemplateConfigOverrideArgs']]]] = None):
        """
        :param pulumi.Input['SpotFleetRequestLaunchTemplateConfigLaunchTemplateSpecificationArgs'] launch_template_specification: Launch template specification. See Launch Template Specification below for more details.
        :param pulumi.Input[List[pulumi.Input['SpotFleetRequestLaunchTemplateConfigOverrideArgs']]] overrides: One or more override configurations. See Overrides below for more details.
        """
        pulumi.set(__self__, "launchTemplateSpecification", launch_template_specification)
        pulumi.set(__self__, "overrides", overrides)

    @property
    @pulumi.getter(name="launchTemplateSpecification")
    def launch_template_specification(self) -> pulumi.Input['SpotFleetRequestLaunchTemplateConfigLaunchTemplateSpecificationArgs']:
        """
        Launch template specification. See Launch Template Specification below for more details.
        """
        ...

    @launch_template_specification.setter
    def launch_template_specification(self, value: pulumi.Input['SpotFleetRequestLaunchTemplateConfigLaunchTemplateSpecificationArgs']):
        ...

    @property
    @pulumi.getter
    def overrides(self) -> Optional[pulumi.Input[List[pulumi.Input['SpotFleetRequestLaunchTemplateConfigOverrideArgs']]]]:
        """
        One or more override configurations. See Overrides below for more details.
        """
        ...

    @overrides.setter
    def overrides(self, value: Optional[pulumi.Input[List[pulumi.Input['SpotFleetRequestLaunchTemplateConfigOverrideArgs']]]]):
        ...


@pulumi.input_type
class SpotFleetRequestLaunchTemplateConfigLaunchTemplateSpecificationArgs:
    def __init__(__self__, *,
                 id: Optional[pulumi.Input[str]] = None,
                 name: Optional[pulumi.Input[str]] = None,
                 version: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] id: The ID of the launch template. Conflicts with `name`.
        :param pulumi.Input[str] name: The name of the launch template. Conflicts with `id`.
        :param pulumi.Input[str] version: Template version. Unlike the autoscaling equivalent, does not support `$Latest` or `$Default`, so use the launch_template resource's attribute, e.g. `"${aws_launch_template.foo.latest_version}"`. It will use the default version if omitted.
        """
        pulumi.set(__self__, "id", id)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "version", version)

    @property
    @pulumi.getter
    def id(self) -> Optional[pulumi.Input[str]]:
        """
        The ID of the launch template. Conflicts with `name`.
        """
        ...

    @id.setter
    def id(self, value: Optional[pulumi.Input[str]]):
        ...

    @property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[str]]:
        """
        The name of the launch template. Conflicts with `id`.
        """
        ...

    @name.setter
    def name(self, value: Optional[pulumi.Input[str]]):
        ...

    @property
    @pulumi.getter
    def version(self) -> Optional[pulumi.Input[str]]:
        """
        Template version. Unlike the autoscaling equivalent, does not support `$Latest` or `$Default`, so use the launch_template resource's attribute, e.g. `"${aws_launch_template.foo.latest_version}"`. It will use the default version if omitted.
        """
        ...

    @version.setter
    def version(self, value: Optional[pulumi.Input[str]]):
        ...


@pulumi.input_type
class SpotFleetRequestLaunchTemplateConfigOverrideArgs:
    def __init__(__self__, *,
                 availability_zone: Optional[pulumi.Input[str]] = None,
                 instance_type: Optional[pulumi.Input[str]] = None,
                 priority: Optional[pulumi.Input[float]] = None,
                 spot_price: Optional[pulumi.Input[str]] = None,
                 subnet_id: Optional[pulumi.Input[str]] = None,
                 weighted_capacity: Optional[pulumi.Input[float]] = None):
        """
        :param pulumi.Input[str] availability_zone: The availability zone in which to place the request.
        :param pulumi.Input[str] instance_type: The type of instance to request.
        :param pulumi.Input[float] priority: The priority for the launch template override. The lower the number, the higher the priority. If no number is set, the launch template override has the lowest priority.
        :param pulumi.Input[str] spot_price: The maximum spot bid for this override request.
        :param pulumi.Input[str] subnet_id: The subnet in which to launch the requested instance.
        :param pulumi.Input[float] weighted_capacity: The capacity added to the fleet by a fulfilled request.
        """
        pulumi.set(__self__, "availabilityZone", availability_zone)
        pulumi.set(__self__, "instanceType", instance_type)
        pulumi.set(__self__, "priority", priority)
        pulumi.set(__self__, "spotPrice", spot_price)
        pulumi.set(__self__, "subnetId", subnet_id)
        pulumi.set(__self__, "weightedCapacity", weighted_capacity)

    @property
    @pulumi.getter(name="availabilityZone")
    def availability_zone(self) -> Optional[pulumi.Input[str]]:
        """
        The availability zone in which to place the request.
        """
        ...

    @availability_zone.setter
    def availability_zone(self, value: Optional[pulumi.Input[str]]):
        ...

    @property
    @pulumi.getter(name="instanceType")
    def instance_type(self) -> Optional[pulumi.Input[str]]:
        """
        The type of instance to request.
        """
        ...

    @instance_type.setter
    def instance_type(self, value: Optional[pulumi.Input[str]]):
        ...

    @property
    @pulumi.getter
    def priority(self) -> Optional[pulumi.Input[float]]:
        """
        The priority for the launch template override. The lower the number, the higher the priority. If no number is set, the launch template override has the lowest priority.
        """
        ...

    @priority.setter
    def priority(self, value: Optional[pulumi.Input[float]]):
        ...

    @property
    @pulumi.getter(name="spotPrice")
    def spot_price(self) -> Optional[pulumi.Input[str]]:
        """
        The maximum spot bid for this override request.
        """
        ...

    @spot_price.setter
    def spot_price(self, value: Optional[pulumi.Input[str]]):
        ...

    @property
    @pulumi.getter(name="subnetId")
    def subnet_id(self) -> Optional[pulumi.Input[str]]:
        """
        The subnet in which to launch the requested instance.
        """
        ...

    @subnet_id.setter
    def subnet_id(self, value: Optional[pulumi.Input[str]]):
        ...

    @property
    @pulumi.getter(name="weightedCapacity")
    def weighted_capacity(self) -> Optional[pulumi.Input[float]]:
        """
        The capacity added to the fleet by a fulfilled request.
        """
        ...

    @weighted_capacity.setter
    def weighted_capacity(self, value: Optional[pulumi.Input[float]]):
        ...


@pulumi.input_type
class SpotInstanceRequestCreditSpecificationArgs:
    def __init__(__self__, *,
                 cpu_credits: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] cpu_credits: The credit option for CPU usage. Can be `"standard"` or `"unlimited"`. T3 instances are launched as unlimited by default. T2 instances are launched as standard by default.
        """
        pulumi.set(__self__, "cpuCredits", cpu_credits)

    @property
    @pulumi.getter(name="cpuCredits")
    def cpu_credits(self) -> Optional[pulumi.Input[str]]:
        """
        The credit option for CPU usage. Can be `"standard"` or `"unlimited"`. T3 instances are launched as unlimited by default. T2 instances are launched as standard by default.
        """
        ...

    @cpu_credits.setter
    def cpu_credits(self, value: Optional[pulumi.Input[str]]):
        ...


@pulumi.input_type
class SpotInstanceRequestEbsBlockDeviceArgs:
    def __init__(__self__, *,
                 device_name: pulumi.Input[str],
                 delete_on_termination: Optional[pulumi.Input[bool]] = None,
                 encrypted: Optional[pulumi.Input[bool]] = None,
                 iops: Optional[pulumi.Input[float]] = None,
                 kms_key_id: Optional[pulumi.Input[str]] = None,
                 snapshot_id: Optional[pulumi.Input[str]] = None,
                 volume_id: Optional[pulumi.Input[str]] = None,
                 volume_size: Optional[pulumi.Input[float]] = None,
                 volume_type: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] device_name: The name of the device to mount.
        :param pulumi.Input[bool] delete_on_termination: Whether the volume should be destroyed
               on instance termination (Default: `true`).
        :param pulumi.Input[bool] encrypted: Enables [EBS
               encryption](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/EBSEncryption.html)
               on the volume (Default: `false`). Cannot be used with `snapshot_id`. Must be configured to perform drift detection.
        :param pulumi.Input[float] iops: The amount of provisioned
               [IOPS](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/ebs-io-characteristics.html).
               This must be set with a `volume_type` of `"io1"`.
        :param pulumi.Input[str] kms_key_id: Amazon Resource Name (ARN) of the KMS Key to use when encrypting the volume. Must be configured to perform drift detection.
        :param pulumi.Input[str] snapshot_id: The Snapshot ID to mount.
        :param pulumi.Input[float] volume_size: The size of the volume in gibibytes (GiB).
        :param pulumi.Input[str] volume_type: The type of volume. Can be `"standard"`, `"gp2"`,
               or `"io1"`. (Default: `"gp2"`).
        """
        pulumi.set(__self__, "deviceName", device_name)
        pulumi.set(__self__, "deleteOnTermination", delete_on_termination)
        pulumi.set(__self__, "encrypted", encrypted)
        pulumi.set(__self__, "iops", iops)
        pulumi.set(__self__, "kmsKeyId", kms_key_id)
        pulumi.set(__self__, "snapshotId", snapshot_id)
        pulumi.set(__self__, "volumeId", volume_id)
        pulumi.set(__self__, "volumeSize", volume_size)
        pulumi.set(__self__, "volumeType", volume_type)

    @property
    @pulumi.getter(name="deviceName")
    def device_name(self) -> pulumi.Input[str]:
        """
        The name of the device to mount.
        """
        ...

    @device_name.setter
    def device_name(self, value: pulumi.Input[str]):
        ...

    @property
    @pulumi.getter(name="deleteOnTermination")
    def delete_on_termination(self) -> Optional[pulumi.Input[bool]]:
        """
        Whether the volume should be destroyed
        on instance termination (Default: `true`).
        """
        ...

    @delete_on_termination.setter
    def delete_on_termination(self, value: Optional[pulumi.Input[bool]]):
        ...

    @property
    @pulumi.getter
    def encrypted(self) -> Optional[pulumi.Input[bool]]:
        """
        Enables [EBS
        encryption](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/EBSEncryption.html)
        on the volume (Default: `false`). Cannot be used with `snapshot_id`. Must be configured to perform drift detection.
        """
        ...

    @encrypted.setter
    def encrypted(self, value: Optional[pulumi.Input[bool]]):
        ...

    @property
    @pulumi.getter
    def iops(self) -> Optional[pulumi.Input[float]]:
        """
        The amount of provisioned
        [IOPS](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/ebs-io-characteristics.html).
        This must be set with a `volume_type` of `"io1"`.
        """
        ...

    @iops.setter
    def iops(self, value: Optional[pulumi.Input[float]]):
        ...

    @property
    @pulumi.getter(name="kmsKeyId")
    def kms_key_id(self) -> Optional[pulumi.Input[str]]:
        """
        Amazon Resource Name (ARN) of the KMS Key to use when encrypting the volume. Must be configured to perform drift detection.
        """
        ...

    @kms_key_id.setter
    def kms_key_id(self, value: Optional[pulumi.Input[str]]):
        ...

    @property
    @pulumi.getter(name="snapshotId")
    def snapshot_id(self) -> Optional[pulumi.Input[str]]:
        """
        The Snapshot ID to mount.
        """
        ...

    @snapshot_id.setter
    def snapshot_id(self, value: Optional[pulumi.Input[str]]):
        ...

    @property
    @pulumi.getter(name="volumeId")
    def volume_id(self) -> Optional[pulumi.Input[str]]:
        ...

    @volume_id.setter
    def volume_id(self, value: Optional[pulumi.Input[str]]):
        ...

    @property
    @pulumi.getter(name="volumeSize")
    def volume_size(self) -> Optional[pulumi.Input[float]]:
        """
        The size of the volume in gibibytes (GiB).
        """
        ...

    @volume_size.setter
    def volume_size(self, value: Optional[pulumi.Input[float]]):
        ...

    @property
    @pulumi.getter(name="volumeType")
    def volume_type(self) -> Optional[pulumi.Input[str]]:
        """
        The type of volume. Can be `"standard"`, `"gp2"`,
        or `"io1"`. (Default: `"gp2"`).
        """
        ...

    @volume_type.setter
    def volume_type(self, value: Optional[pulumi.Input[str]]):
        ...


@pulumi.input_type
class SpotInstanceRequestEphemeralBlockDeviceArgs:
    def __init__(__self__, *,
                 device_name: pulumi.Input[str],
                 no_device: Optional[pulumi.Input[bool]] = None,
                 virtual_name: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] device_name: The name of the block device to mount on the instance.
        :param pulumi.Input[bool] no_device: Suppresses the specified device included in the AMI's block device mapping.
        :param pulumi.Input[str] virtual_name: The [Instance Store Device
               Name](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/InstanceStorage.html#InstanceStoreDeviceNames)
               (e.g. `"ephemeral0"`).
        """
        pulumi.set(__self__, "deviceName", device_name)
        pulumi.set(__self__, "noDevice", no_device)
        pulumi.set(__self__, "virtualName", virtual_name)

    @property
    @pulumi.getter(name="deviceName")
    def device_name(self) -> pulumi.Input[str]:
        """
        The name of the block device to mount on the instance.
        """
        ...

    @device_name.setter
    def device_name(self, value: pulumi.Input[str]):
        ...

    @property
    @pulumi.getter(name="noDevice")
    def no_device(self) -> Optional[pulumi.Input[bool]]:
        """
        Suppresses the specified device included in the AMI's block device mapping.
        """
        ...

    @no_device.setter
    def no_device(self, value: Optional[pulumi.Input[bool]]):
        ...

    @property
    @pulumi.getter(name="virtualName")
    def virtual_name(self) -> Optional[pulumi.Input[str]]:
        """
        The [Instance Store Device
        Name](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/InstanceStorage.html#InstanceStoreDeviceNames)
        (e.g. `"ephemeral0"`).
        """
        ...

    @virtual_name.setter
    def virtual_name(self, value: Optional[pulumi.Input[str]]):
        ...


@pulumi.input_type
class SpotInstanceRequestMetadataOptionsArgs:
    def __init__(__self__, *,
                 http_endpoint: Optional[pulumi.Input[str]] = None,
                 http_put_response_hop_limit: Optional[pulumi.Input[float]] = None,
                 http_tokens: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] http_endpoint: Whether the metadata service is available. Can be `"enabled"` or `"disabled"`. (Default: `"enabled"`).
        :param pulumi.Input[float] http_put_response_hop_limit: The desired HTTP PUT response hop limit for instance metadata requests. The larger the number, the further instance metadata requests can travel. Can be an integer from `1` to `64`. (Default: `1`).
        :param pulumi.Input[str] http_tokens: Whether or not the metadata service requires session tokens, also referred to as _Instance Metadata Service Version 2_. Can be `"optional"` or `"required"`. (Default: `"optional"`).
        """
        pulumi.set(__self__, "httpEndpoint", http_endpoint)
        pulumi.set(__self__, "httpPutResponseHopLimit", http_put_response_hop_limit)
        pulumi.set(__self__, "httpTokens", http_tokens)

    @property
    @pulumi.getter(name="httpEndpoint")
    def http_endpoint(self) -> Optional[pulumi.Input[str]]:
        """
        Whether the metadata service is available. Can be `"enabled"` or `"disabled"`. (Default: `"enabled"`).
        """
        ...

    @http_endpoint.setter
    def http_endpoint(self, value: Optional[pulumi.Input[str]]):
        ...

    @property
    @pulumi.getter(name="httpPutResponseHopLimit")
    def http_put_response_hop_limit(self) -> Optional[pulumi.Input[float]]:
        """
        The desired HTTP PUT response hop limit for instance metadata requests. The larger the number, the further instance metadata requests can travel. Can be an integer from `1` to `64`. (Default: `1`).
        """
        ...

    @http_put_response_hop_limit.setter
    def http_put_response_hop_limit(self, value: Optional[pulumi.Input[float]]):
        ...

    @property
    @pulumi.getter(name="httpTokens")
    def http_tokens(self) -> Optional[pulumi.Input[str]]:
        """
        Whether or not the metadata service requires session tokens, also referred to as _Instance Metadata Service Version 2_. Can be `"optional"` or `"required"`. (Default: `"optional"`).
        """
        ...

    @http_tokens.setter
    def http_tokens(self, value: Optional[pulumi.Input[str]]):
        ...


@pulumi.input_type
class SpotInstanceRequestNetworkInterfaceArgs:
    def __init__(__self__, *,
                 device_index: pulumi.Input[float],
                 network_interface_id: pulumi.Input[str],
                 delete_on_termination: Optional[pulumi.Input[bool]] = None):
        """
        :param pulumi.Input[float] device_index: The integer index of the network interface attachment. Limited by instance type.
        :param pulumi.Input[str] network_interface_id: The ID of the network interface to attach.
        :param pulumi.Input[bool] delete_on_termination: Whether or not to delete the network interface on instance termination. Defaults to `false`. Currently, the only valid value is `false`, as this is only supported when creating new network interfaces when launching an instance.
        """
        pulumi.set(__self__, "deviceIndex", device_index)
        pulumi.set(__self__, "networkInterfaceId", network_interface_id)
        pulumi.set(__self__, "deleteOnTermination", delete_on_termination)

    @property
    @pulumi.getter(name="deviceIndex")
    def device_index(self) -> pulumi.Input[float]:
        """
        The integer index of the network interface attachment. Limited by instance type.
        """
        ...

    @device_index.setter
    def device_index(self, value: pulumi.Input[float]):
        ...

    @property
    @pulumi.getter(name="networkInterfaceId")
    def network_interface_id(self) -> pulumi.Input[str]:
        """
        The ID of the network interface to attach.
        """
        ...

    @network_interface_id.setter
    def network_interface_id(self, value: pulumi.Input[str]):
        ...

    @property
    @pulumi.getter(name="deleteOnTermination")
    def delete_on_termination(self) -> Optional[pulumi.Input[bool]]:
        """
        Whether or not to delete the network interface on instance termination. Defaults to `false`. Currently, the only valid value is `false`, as this is only supported when creating new network interfaces when launching an instance.
        """
        ...

    @delete_on_termination.setter
    def delete_on_termination(self, value: Optional[pulumi.Input[bool]]):
        ...


@pulumi.input_type
class SpotInstanceRequestRootBlockDeviceArgs:
    def __init__(__self__, *,
                 delete_on_termination: Optional[pulumi.Input[bool]] = None,
                 device_name: Optional[pulumi.Input[str]] = None,
                 encrypted: Optional[pulumi.Input[bool]] = None,
                 iops: Optional[pulumi.Input[float]] = None,
                 kms_key_id: Optional[pulumi.Input[str]] = None,
                 volume_id: Optional[pulumi.Input[str]] = None,
                 volume_size: Optional[pulumi.Input[float]] = None,
                 volume_type: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[bool] delete_on_termination: Whether the volume should be destroyed
               on instance termination (Default: `true`).
        :param pulumi.Input[str] device_name: The name of the device to mount.
        :param pulumi.Input[bool] encrypted: Enable volume encryption. (Default: `false`). Must be configured to perform drift detection.
        :param pulumi.Input[float] iops: The amount of provisioned
               [IOPS](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/ebs-io-characteristics.html).
               This is only valid for `volume_type` of `"io1"`, and must be specified if
               using that type
        :param pulumi.Input[str] kms_key_id: Amazon Resource Name (ARN) of the KMS Key to use when encrypting the volume. Must be configured to perform drift detection.
        :param pulumi.Input[float] volume_size: The size of the volume in gibibytes (GiB).
        :param pulumi.Input[str] volume_type: The type of volume. Can be `"standard"`, `"gp2"`, `"io1"`, `"sc1"`, or `"st1"`. (Default: `"standard"`).
        """
        pulumi.set(__self__, "deleteOnTermination", delete_on_termination)
        pulumi.set(__self__, "deviceName", device_name)
        pulumi.set(__self__, "encrypted", encrypted)
        pulumi.set(__self__, "iops", iops)
        pulumi.set(__self__, "kmsKeyId", kms_key_id)
        pulumi.set(__self__, "volumeId", volume_id)
        pulumi.set(__self__, "volumeSize", volume_size)
        pulumi.set(__self__, "volumeType", volume_type)

    @property
    @pulumi.getter(name="deleteOnTermination")
    def delete_on_termination(self) -> Optional[pulumi.Input[bool]]:
        """
        Whether the volume should be destroyed
        on instance termination (Default: `true`).
        """
        ...

    @delete_on_termination.setter
    def delete_on_termination(self, value: Optional[pulumi.Input[bool]]):
        ...

    @property
    @pulumi.getter(name="deviceName")
    def device_name(self) -> Optional[pulumi.Input[str]]:
        """
        The name of the device to mount.
        """
        ...

    @device_name.setter
    def device_name(self, value: Optional[pulumi.Input[str]]):
        ...

    @property
    @pulumi.getter
    def encrypted(self) -> Optional[pulumi.Input[bool]]:
        """
        Enable volume encryption. (Default: `false`). Must be configured to perform drift detection.
        """
        ...

    @encrypted.setter
    def encrypted(self, value: Optional[pulumi.Input[bool]]):
        ...

    @property
    @pulumi.getter
    def iops(self) -> Optional[pulumi.Input[float]]:
        """
        The amount of provisioned
        [IOPS](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/ebs-io-characteristics.html).
        This is only valid for `volume_type` of `"io1"`, and must be specified if
        using that type
        """
        ...

    @iops.setter
    def iops(self, value: Optional[pulumi.Input[float]]):
        ...

    @property
    @pulumi.getter(name="kmsKeyId")
    def kms_key_id(self) -> Optional[pulumi.Input[str]]:
        """
        Amazon Resource Name (ARN) of the KMS Key to use when encrypting the volume. Must be configured to perform drift detection.
        """
        ...

    @kms_key_id.setter
    def kms_key_id(self, value: Optional[pulumi.Input[str]]):
        ...

    @property
    @pulumi.getter(name="volumeId")
    def volume_id(self) -> Optional[pulumi.Input[str]]:
        ...

    @volume_id.setter
    def volume_id(self, value: Optional[pulumi.Input[str]]):
        ...

    @property
    @pulumi.getter(name="volumeSize")
    def volume_size(self) -> Optional[pulumi.Input[float]]:
        """
        The size of the volume in gibibytes (GiB).
        """
        ...

    @volume_size.setter
    def volume_size(self, value: Optional[pulumi.Input[float]]):
        ...

    @property
    @pulumi.getter(name="volumeType")
    def volume_type(self) -> Optional[pulumi.Input[str]]:
        """
        The type of volume. Can be `"standard"`, `"gp2"`, `"io1"`, `"sc1"`, or `"st1"`. (Default: `"standard"`).
        """
        ...

    @volume_type.setter
    def volume_type(self, value: Optional[pulumi.Input[str]]):
        ...


@pulumi.input_type
class TrafficMirrorFilterRuleDestinationPortRangeArgs:
    def __init__(__self__, *,
                 from_port: Optional[pulumi.Input[float]] = None,
                 to_port: Optional[pulumi.Input[float]] = None):
        """
        :param pulumi.Input[float] from_port: Starting port of the range
        :param pulumi.Input[float] to_port: Ending port of the range
        """
        pulumi.set(__self__, "fromPort", from_port)
        pulumi.set(__self__, "toPort", to_port)

    @property
    @pulumi.getter(name="fromPort")
    def from_port(self) -> Optional[pulumi.Input[float]]:
        """
        Starting port of the range
        """
        ...

    @from_port.setter
    def from_port(self, value: Optional[pulumi.Input[float]]):
        ...

    @property
    @pulumi.getter(name="toPort")
    def to_port(self) -> Optional[pulumi.Input[float]]:
        """
        Ending port of the range
        """
        ...

    @to_port.setter
    def to_port(self, value: Optional[pulumi.Input[float]]):
        ...


@pulumi.input_type
class TrafficMirrorFilterRuleSourcePortRangeArgs:
    def __init__(__self__, *,
                 from_port: Optional[pulumi.Input[float]] = None,
                 to_port: Optional[pulumi.Input[float]] = None):
        """
        :param pulumi.Input[float] from_port: Starting port of the range
        :param pulumi.Input[float] to_port: Ending port of the range
        """
        pulumi.set(__self__, "fromPort", from_port)
        pulumi.set(__self__, "toPort", to_port)

    @property
    @pulumi.getter(name="fromPort")
    def from_port(self) -> Optional[pulumi.Input[float]]:
        """
        Starting port of the range
        """
        ...

    @from_port.setter
    def from_port(self, value: Optional[pulumi.Input[float]]):
        ...

    @property
    @pulumi.getter(name="toPort")
    def to_port(self) -> Optional[pulumi.Input[float]]:
        """
        Ending port of the range
        """
        ...

    @to_port.setter
    def to_port(self, value: Optional[pulumi.Input[float]]):
        ...


@pulumi.input_type
class VpcEndpointDnsEntryArgs:
    def __init__(__self__, *,
                 dns_name: Optional[pulumi.Input[str]] = None,
                 hosted_zone_id: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] dns_name: The DNS name.
        :param pulumi.Input[str] hosted_zone_id: The ID of the private hosted zone.
        """
        pulumi.set(__self__, "dnsName", dns_name)
        pulumi.set(__self__, "hostedZoneId", hosted_zone_id)

    @property
    @pulumi.getter(name="dnsName")
    def dns_name(self) -> Optional[pulumi.Input[str]]:
        """
        The DNS name.
        """
        ...

    @dns_name.setter
    def dns_name(self, value: Optional[pulumi.Input[str]]):
        ...

    @property
    @pulumi.getter(name="hostedZoneId")
    def hosted_zone_id(self) -> Optional[pulumi.Input[str]]:
        """
        The ID of the private hosted zone.
        """
        ...

    @hosted_zone_id.setter
    def hosted_zone_id(self, value: Optional[pulumi.Input[str]]):
        ...


@pulumi.input_type
class VpcPeeringConnectionAccepterArgs:
    def __init__(__self__, *,
                 allow_classic_link_to_remote_vpc: Optional[pulumi.Input[bool]] = None,
                 allow_remote_vpc_dns_resolution: Optional[pulumi.Input[bool]] = None,
                 allow_vpc_to_remote_classic_link: Optional[pulumi.Input[bool]] = None):
        """
        :param pulumi.Input[bool] allow_classic_link_to_remote_vpc: Allow a local linked EC2-Classic instance to communicate
               with instances in a peer VPC. This enables an outbound communication from the local ClassicLink connection
               to the remote VPC.
        :param pulumi.Input[bool] allow_remote_vpc_dns_resolution: Allow a local VPC to resolve public DNS hostnames to
               private IP addresses when queried from instances in the peer VPC. This is
               [not supported](https://docs.aws.amazon.com/vpc/latest/peering/modify-peering-connections.html) for
               inter-region VPC peering.
        :param pulumi.Input[bool] allow_vpc_to_remote_classic_link: Allow a local VPC to communicate with a linked EC2-Classic
               instance in a peer VPC. This enables an outbound communication from the local VPC to the remote ClassicLink
               connection.
        """
        pulumi.set(__self__, "allowClassicLinkToRemoteVpc", allow_classic_link_to_remote_vpc)
        pulumi.set(__self__, "allowRemoteVpcDnsResolution", allow_remote_vpc_dns_resolution)
        pulumi.set(__self__, "allowVpcToRemoteClassicLink", allow_vpc_to_remote_classic_link)

    @property
    @pulumi.getter(name="allowClassicLinkToRemoteVpc")
    def allow_classic_link_to_remote_vpc(self) -> Optional[pulumi.Input[bool]]:
        """
        Allow a local linked EC2-Classic instance to communicate
        with instances in a peer VPC. This enables an outbound communication from the local ClassicLink connection
        to the remote VPC.
        """
        ...

    @allow_classic_link_to_remote_vpc.setter
    def allow_classic_link_to_remote_vpc(self, value: Optional[pulumi.Input[bool]]):
        ...

    @property
    @pulumi.getter(name="allowRemoteVpcDnsResolution")
    def allow_remote_vpc_dns_resolution(self) -> Optional[pulumi.Input[bool]]:
        """
        Allow a local VPC to resolve public DNS hostnames to
        private IP addresses when queried from instances in the peer VPC. This is
        [not supported](https://docs.aws.amazon.com/vpc/latest/peering/modify-peering-connections.html) for
        inter-region VPC peering.
        """
        ...

    @allow_remote_vpc_dns_resolution.setter
    def allow_remote_vpc_dns_resolution(self, value: Optional[pulumi.Input[bool]]):
        ...

    @property
    @pulumi.getter(name="allowVpcToRemoteClassicLink")
    def allow_vpc_to_remote_classic_link(self) -> Optional[pulumi.Input[bool]]:
        """
        Allow a local VPC to communicate with a linked EC2-Classic
        instance in a peer VPC. This enables an outbound communication from the local VPC to the remote ClassicLink
        connection.
        """
        ...

    @allow_vpc_to_remote_classic_link.setter
    def allow_vpc_to_remote_classic_link(self, value: Optional[pulumi.Input[bool]]):
        ...


@pulumi.input_type
class VpcPeeringConnectionAccepterAccepterArgs:
    def __init__(__self__, *,
                 allow_classic_link_to_remote_vpc: Optional[pulumi.Input[bool]] = None,
                 allow_remote_vpc_dns_resolution: Optional[pulumi.Input[bool]] = None,
                 allow_vpc_to_remote_classic_link: Optional[pulumi.Input[bool]] = None):
        """
        :param pulumi.Input[bool] allow_classic_link_to_remote_vpc: Indicates whether a local ClassicLink connection can communicate
               with the peer VPC over the VPC Peering Connection.
        :param pulumi.Input[bool] allow_remote_vpc_dns_resolution: Indicates whether a local VPC can resolve public DNS hostnames to
               private IP addresses when queried from instances in a peer VPC.
        :param pulumi.Input[bool] allow_vpc_to_remote_classic_link: Indicates whether a local VPC can communicate with a ClassicLink
               connection in the peer VPC over the VPC Peering Connection.
        """
        pulumi.set(__self__, "allowClassicLinkToRemoteVpc", allow_classic_link_to_remote_vpc)
        pulumi.set(__self__, "allowRemoteVpcDnsResolution", allow_remote_vpc_dns_resolution)
        pulumi.set(__self__, "allowVpcToRemoteClassicLink", allow_vpc_to_remote_classic_link)

    @property
    @pulumi.getter(name="allowClassicLinkToRemoteVpc")
    def allow_classic_link_to_remote_vpc(self) -> Optional[pulumi.Input[bool]]:
        """
        Indicates whether a local ClassicLink connection can communicate
        with the peer VPC over the VPC Peering Connection.
        """
        ...

    @allow_classic_link_to_remote_vpc.setter
    def allow_classic_link_to_remote_vpc(self, value: Optional[pulumi.Input[bool]]):
        ...

    @property
    @pulumi.getter(name="allowRemoteVpcDnsResolution")
    def allow_remote_vpc_dns_resolution(self) -> Optional[pulumi.Input[bool]]:
        """
        Indicates whether a local VPC can resolve public DNS hostnames to
        private IP addresses when queried from instances in a peer VPC.
        """
        ...

    @allow_remote_vpc_dns_resolution.setter
    def allow_remote_vpc_dns_resolution(self, value: Optional[pulumi.Input[bool]]):
        ...

    @property
    @pulumi.getter(name="allowVpcToRemoteClassicLink")
    def allow_vpc_to_remote_classic_link(self) -> Optional[pulumi.Input[bool]]:
        """
        Indicates whether a local VPC can communicate with a ClassicLink
        connection in the peer VPC over the VPC Peering Connection.
        """
        ...

    @allow_vpc_to_remote_classic_link.setter
    def allow_vpc_to_remote_classic_link(self, value: Optional[pulumi.Input[bool]]):
        ...


@pulumi.input_type
class VpcPeeringConnectionAccepterRequesterArgs:
    def __init__(__self__, *,
                 allow_classic_link_to_remote_vpc: Optional[pulumi.Input[bool]] = None,
                 allow_remote_vpc_dns_resolution: Optional[pulumi.Input[bool]] = None,
                 allow_vpc_to_remote_classic_link: Optional[pulumi.Input[bool]] = None):
        """
        :param pulumi.Input[bool] allow_classic_link_to_remote_vpc: Indicates whether a local ClassicLink connection can communicate
               with the peer VPC over the VPC Peering Connection.
        :param pulumi.Input[bool] allow_remote_vpc_dns_resolution: Indicates whether a local VPC can resolve public DNS hostnames to
               private IP addresses when queried from instances in a peer VPC.
        :param pulumi.Input[bool] allow_vpc_to_remote_classic_link: Indicates whether a local VPC can communicate with a ClassicLink
               connection in the peer VPC over the VPC Peering Connection.
        """
        pulumi.set(__self__, "allowClassicLinkToRemoteVpc", allow_classic_link_to_remote_vpc)
        pulumi.set(__self__, "allowRemoteVpcDnsResolution", allow_remote_vpc_dns_resolution)
        pulumi.set(__self__, "allowVpcToRemoteClassicLink", allow_vpc_to_remote_classic_link)

    @property
    @pulumi.getter(name="allowClassicLinkToRemoteVpc")
    def allow_classic_link_to_remote_vpc(self) -> Optional[pulumi.Input[bool]]:
        """
        Indicates whether a local ClassicLink connection can communicate
        with the peer VPC over the VPC Peering Connection.
        """
        ...

    @allow_classic_link_to_remote_vpc.setter
    def allow_classic_link_to_remote_vpc(self, value: Optional[pulumi.Input[bool]]):
        ...

    @property
    @pulumi.getter(name="allowRemoteVpcDnsResolution")
    def allow_remote_vpc_dns_resolution(self) -> Optional[pulumi.Input[bool]]:
        """
        Indicates whether a local VPC can resolve public DNS hostnames to
        private IP addresses when queried from instances in a peer VPC.
        """
        ...

    @allow_remote_vpc_dns_resolution.setter
    def allow_remote_vpc_dns_resolution(self, value: Optional[pulumi.Input[bool]]):
        ...

    @property
    @pulumi.getter(name="allowVpcToRemoteClassicLink")
    def allow_vpc_to_remote_classic_link(self) -> Optional[pulumi.Input[bool]]:
        """
        Indicates whether a local VPC can communicate with a ClassicLink
        connection in the peer VPC over the VPC Peering Connection.
        """
        ...

    @allow_vpc_to_remote_classic_link.setter
    def allow_vpc_to_remote_classic_link(self, value: Optional[pulumi.Input[bool]]):
        ...


@pulumi.input_type
class VpcPeeringConnectionRequesterArgs:
    def __init__(__self__, *,
                 allow_classic_link_to_remote_vpc: Optional[pulumi.Input[bool]] = None,
                 allow_remote_vpc_dns_resolution: Optional[pulumi.Input[bool]] = None,
                 allow_vpc_to_remote_classic_link: Optional[pulumi.Input[bool]] = None):
        """
        :param pulumi.Input[bool] allow_classic_link_to_remote_vpc: Allow a local linked EC2-Classic instance to communicate
               with instances in a peer VPC. This enables an outbound communication from the local ClassicLink connection
               to the remote VPC.
        :param pulumi.Input[bool] allow_remote_vpc_dns_resolution: Allow a local VPC to resolve public DNS hostnames to
               private IP addresses when queried from instances in the peer VPC. This is
               [not supported](https://docs.aws.amazon.com/vpc/latest/peering/modify-peering-connections.html) for
               inter-region VPC peering.
        :param pulumi.Input[bool] allow_vpc_to_remote_classic_link: Allow a local VPC to communicate with a linked EC2-Classic
               instance in a peer VPC. This enables an outbound communication from the local VPC to the remote ClassicLink
               connection.
        """
        pulumi.set(__self__, "allowClassicLinkToRemoteVpc", allow_classic_link_to_remote_vpc)
        pulumi.set(__self__, "allowRemoteVpcDnsResolution", allow_remote_vpc_dns_resolution)
        pulumi.set(__self__, "allowVpcToRemoteClassicLink", allow_vpc_to_remote_classic_link)

    @property
    @pulumi.getter(name="allowClassicLinkToRemoteVpc")
    def allow_classic_link_to_remote_vpc(self) -> Optional[pulumi.Input[bool]]:
        """
        Allow a local linked EC2-Classic instance to communicate
        with instances in a peer VPC. This enables an outbound communication from the local ClassicLink connection
        to the remote VPC.
        """
        ...

    @allow_classic_link_to_remote_vpc.setter
    def allow_classic_link_to_remote_vpc(self, value: Optional[pulumi.Input[bool]]):
        ...

    @property
    @pulumi.getter(name="allowRemoteVpcDnsResolution")
    def allow_remote_vpc_dns_resolution(self) -> Optional[pulumi.Input[bool]]:
        """
        Allow a local VPC to resolve public DNS hostnames to
        private IP addresses when queried from instances in the peer VPC. This is
        [not supported](https://docs.aws.amazon.com/vpc/latest/peering/modify-peering-connections.html) for
        inter-region VPC peering.
        """
        ...

    @allow_remote_vpc_dns_resolution.setter
    def allow_remote_vpc_dns_resolution(self, value: Optional[pulumi.Input[bool]]):
        ...

    @property
    @pulumi.getter(name="allowVpcToRemoteClassicLink")
    def allow_vpc_to_remote_classic_link(self) -> Optional[pulumi.Input[bool]]:
        """
        Allow a local VPC to communicate with a linked EC2-Classic
        instance in a peer VPC. This enables an outbound communication from the local VPC to the remote ClassicLink
        connection.
        """
        ...

    @allow_vpc_to_remote_classic_link.setter
    def allow_vpc_to_remote_classic_link(self, value: Optional[pulumi.Input[bool]]):
        ...


@pulumi.input_type
class VpnConnectionRouteArgs:
    def __init__(__self__, *,
                 destination_cidr_block: Optional[pulumi.Input[str]] = None,
                 source: Optional[pulumi.Input[str]] = None,
                 state: Optional[pulumi.Input[str]] = None):
        pulumi.set(__self__, "destinationCidrBlock", destination_cidr_block)
        pulumi.set(__self__, "source", source)
        pulumi.set(__self__, "state", state)

    @property
    @pulumi.getter(name="destinationCidrBlock")
    def destination_cidr_block(self) -> Optional[pulumi.Input[str]]:
        ...

    @destination_cidr_block.setter
    def destination_cidr_block(self, value: Optional[pulumi.Input[str]]):
        ...

    @property
    @pulumi.getter
    def source(self) -> Optional[pulumi.Input[str]]:
        ...

    @source.setter
    def source(self, value: Optional[pulumi.Input[str]]):
        ...

    @property
    @pulumi.getter
    def state(self) -> Optional[pulumi.Input[str]]:
        ...

    @state.setter
    def state(self, value: Optional[pulumi.Input[str]]):
        ...


@pulumi.input_type
class VpnConnectionVgwTelemetryArgs:
    def __init__(__self__, *,
                 accepted_route_count: Optional[pulumi.Input[float]] = None,
                 last_status_change: Optional[pulumi.Input[str]] = None,
                 outside_ip_address: Optional[pulumi.Input[str]] = None,
                 status: Optional[pulumi.Input[str]] = None,
                 status_message: Optional[pulumi.Input[str]] = None):
        pulumi.set(__self__, "acceptedRouteCount", accepted_route_count)
        pulumi.set(__self__, "lastStatusChange", last_status_change)
        pulumi.set(__self__, "outsideIpAddress", outside_ip_address)
        pulumi.set(__self__, "status", status)
        pulumi.set(__self__, "statusMessage", status_message)

    @property
    @pulumi.getter(name="acceptedRouteCount")
    def accepted_route_count(self) -> Optional[pulumi.Input[float]]:
        ...

    @accepted_route_count.setter
    def accepted_route_count(self, value: Optional[pulumi.Input[float]]):
        ...

    @property
    @pulumi.getter(name="lastStatusChange")
    def last_status_change(self) -> Optional[pulumi.Input[str]]:
        ...

    @last_status_change.setter
    def last_status_change(self, value: Optional[pulumi.Input[str]]):
        ...

    @property
    @pulumi.getter(name="outsideIpAddress")
    def outside_ip_address(self) -> Optional[pulumi.Input[str]]:
        ...

    @outside_ip_address.setter
    def outside_ip_address(self, value: Optional[pulumi.Input[str]]):
        ...

    @property
    @pulumi.getter
    def status(self) -> Optional[pulumi.Input[str]]:
        ...

    @status.setter
    def status(self, value: Optional[pulumi.Input[str]]):
        ...

    @property
    @pulumi.getter(name="statusMessage")
    def status_message(self) -> Optional[pulumi.Input[str]]:
        ...

    @status_message.setter
    def status_message(self, value: Optional[pulumi.Input[str]]):
        ...


@pulumi.input_type
class GetCoipPoolFilterArgs:
    def __init__(__self__, *,
                 name: str,
                 values: List[str]):
        """
        :param str name: The name of the field to filter by, as defined by
               [the underlying AWS API](https://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_DescribeCoipPools.html).
        :param List[str] values: Set of values that are accepted for the given field.
               A COIP Pool will be selected if any one of the given values matches.
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "values", values)

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        The name of the field to filter by, as defined by
        [the underlying AWS API](https://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_DescribeCoipPools.html).
        """
        ...

    @name.setter
    def name(self, value: str):
        ...

    @property
    @pulumi.getter
    def values(self) -> List[str]:
        """
        Set of values that are accepted for the given field.
        A COIP Pool will be selected if any one of the given values matches.
        """
        ...

    @values.setter
    def values(self, value: List[str]):
        ...


@pulumi.input_type
class GetCoipPoolsFilterArgs:
    def __init__(__self__, *,
                 name: str,
                 values: List[str]):
        """
        :param str name: The name of the field to filter by, as defined by
               [the underlying AWS API](https://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_DescribeCoipPools.html).
        :param List[str] values: Set of values that are accepted for the given field.
               A COIP Pool will be selected if any one of the given values matches.
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "values", values)

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        The name of the field to filter by, as defined by
        [the underlying AWS API](https://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_DescribeCoipPools.html).
        """
        ...

    @name.setter
    def name(self, value: str):
        ...

    @property
    @pulumi.getter
    def values(self) -> List[str]:
        """
        Set of values that are accepted for the given field.
        A COIP Pool will be selected if any one of the given values matches.
        """
        ...

    @values.setter
    def values(self, value: List[str]):
        ...


@pulumi.input_type
class GetCustomerGatewayFilterArgs:
    def __init__(__self__, *,
                 name: str,
                 values: List[str]):
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "values", values)

    @property
    @pulumi.getter
    def name(self) -> str:
        ...

    @name.setter
    def name(self, value: str):
        ...

    @property
    @pulumi.getter
    def values(self) -> List[str]:
        ...

    @values.setter
    def values(self, value: List[str]):
        ...


@pulumi.input_type
class GetInstanceFilterArgs:
    def __init__(__self__, *,
                 name: str,
                 values: List[str]):
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "values", values)

    @property
    @pulumi.getter
    def name(self) -> str:
        ...

    @name.setter
    def name(self, value: str):
        ...

    @property
    @pulumi.getter
    def values(self) -> List[str]:
        ...

    @values.setter
    def values(self, value: List[str]):
        ...


@pulumi.input_type
class GetInstanceTypeOfferingFilterArgs:
    def __init__(__self__, *,
                 name: str,
                 values: List[str]):
        """
        :param str name: Name of the filter. The `location` filter depends on the top-level `location_type` argument and if not specified, defaults to the current region.
        :param List[str] values: List of one or more values for the filter.
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "values", values)

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        Name of the filter. The `location` filter depends on the top-level `location_type` argument and if not specified, defaults to the current region.
        """
        ...

    @name.setter
    def name(self, value: str):
        ...

    @property
    @pulumi.getter
    def values(self) -> List[str]:
        """
        List of one or more values for the filter.
        """
        ...

    @values.setter
    def values(self, value: List[str]):
        ...


@pulumi.input_type
class GetInstanceTypeOfferingsFilterArgs:
    def __init__(__self__, *,
                 name: str,
                 values: List[str]):
        """
        :param str name: Name of the filter. The `location` filter depends on the top-level `location_type` argument and if not specified, defaults to the current region.
        :param List[str] values: List of one or more values for the filter.
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "values", values)

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        Name of the filter. The `location` filter depends on the top-level `location_type` argument and if not specified, defaults to the current region.
        """
        ...

    @name.setter
    def name(self, value: str):
        ...

    @property
    @pulumi.getter
    def values(self) -> List[str]:
        """
        List of one or more values for the filter.
        """
        ...

    @values.setter
    def values(self, value: List[str]):
        ...


@pulumi.input_type
class GetInstancesFilterArgs:
    def __init__(__self__, *,
                 name: str,
                 values: List[str]):
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "values", values)

    @property
    @pulumi.getter
    def name(self) -> str:
        ...

    @name.setter
    def name(self, value: str):
        ...

    @property
    @pulumi.getter
    def values(self) -> List[str]:
        ...

    @values.setter
    def values(self, value: List[str]):
        ...


@pulumi.input_type
class GetInternetGatewayFilterArgs:
    def __init__(__self__, *,
                 name: str,
                 values: List[str]):
        """
        :param str name: The name of the field to filter by, as defined by
               [the underlying AWS API](https://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_DescribeInternetGateways.html).
        :param List[str] values: Set of values that are accepted for the given field.
               An Internet Gateway will be selected if any one of the given values matches.
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "values", values)

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        The name of the field to filter by, as defined by
        [the underlying AWS API](https://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_DescribeInternetGateways.html).
        """
        ...

    @name.setter
    def name(self, value: str):
        ...

    @property
    @pulumi.getter
    def values(self) -> List[str]:
        """
        Set of values that are accepted for the given field.
        An Internet Gateway will be selected if any one of the given values matches.
        """
        ...

    @values.setter
    def values(self, value: List[str]):
        ...


@pulumi.input_type
class GetLaunchTemplateFilterArgs:
    def __init__(__self__, *,
                 name: str,
                 values: List[str]):
        """
        :param str name: The name of the filter field. Valid values can be found in the [EC2 DescribeLaunchTemplates API Reference](https://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_DescribeLaunchTemplates.html).
        :param List[str] values: Set of values that are accepted for the given filter field. Results will be selected if any given value matches.
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "values", values)

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        The name of the filter field. Valid values can be found in the [EC2 DescribeLaunchTemplates API Reference](https://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_DescribeLaunchTemplates.html).
        """
        ...

    @name.setter
    def name(self, value: str):
        ...

    @property
    @pulumi.getter
    def values(self) -> List[str]:
        """
        Set of values that are accepted for the given filter field. Results will be selected if any given value matches.
        """
        ...

    @values.setter
    def values(self, value: List[str]):
        ...


@pulumi.input_type
class GetLocalGatewayFilterArgs:
    def __init__(__self__, *,
                 name: str,
                 values: List[str]):
        """
        :param str name: The name of the field to filter by, as defined by
               [the underlying AWS API](https://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_DescribeLocalGateways.html).
        :param List[str] values: Set of values that are accepted for the given field.
               A Local Gateway will be selected if any one of the given values matches.
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "values", values)

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        The name of the field to filter by, as defined by
        [the underlying AWS API](https://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_DescribeLocalGateways.html).
        """
        ...

    @name.setter
    def name(self, value: str):
        ...

    @property
    @pulumi.getter
    def values(self) -> List[str]:
        """
        Set of values that are accepted for the given field.
        A Local Gateway will be selected if any one of the given values matches.
        """
        ...

    @values.setter
    def values(self, value: List[str]):
        ...


@pulumi.input_type
class GetLocalGatewayRouteTableFilterArgs:
    def __init__(__self__, *,
                 name: str,
                 values: List[str]):
        """
        :param str name: The name of the field to filter by, as defined by
               [the underlying AWS API](https://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_DescribeLocalGatewayRouteTables.html).
        :param List[str] values: Set of values that are accepted for the given field.
               A local gateway route table will be selected if any one of the given values matches.
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "values", values)

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        The name of the field to filter by, as defined by
        [the underlying AWS API](https://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_DescribeLocalGatewayRouteTables.html).
        """
        ...

    @name.setter
    def name(self, value: str):
        ...

    @property
    @pulumi.getter
    def values(self) -> List[str]:
        """
        Set of values that are accepted for the given field.
        A local gateway route table will be selected if any one of the given values matches.
        """
        ...

    @values.setter
    def values(self, value: List[str]):
        ...


@pulumi.input_type
class GetLocalGatewayRouteTablesFilterArgs:
    def __init__(__self__, *,
                 name: str,
                 values: List[str]):
        """
        :param str name: The name of the field to filter by, as defined by
               [the underlying AWS API](https://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_DescribeLocalGatewayRouteTables.html).
        :param List[str] values: Set of values that are accepted for the given field.
               A Local Gateway Route Table will be selected if any one of the given values matches.
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "values", values)

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        The name of the field to filter by, as defined by
        [the underlying AWS API](https://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_DescribeLocalGatewayRouteTables.html).
        """
        ...

    @name.setter
    def name(self, value: str):
        ...

    @property
    @pulumi.getter
    def values(self) -> List[str]:
        """
        Set of values that are accepted for the given field.
        A Local Gateway Route Table will be selected if any one of the given values matches.
        """
        ...

    @values.setter
    def values(self, value: List[str]):
        ...


@pulumi.input_type
class GetLocalGatewayVirtualInterfaceFilterArgs:
    def __init__(__self__, *,
                 name: str,
                 values: List[str]):
        """
        :param str name: Name of the filter.
        :param List[str] values: List of one or more values for the filter.
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "values", values)

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        Name of the filter.
        """
        ...

    @name.setter
    def name(self, value: str):
        ...

    @property
    @pulumi.getter
    def values(self) -> List[str]:
        """
        List of one or more values for the filter.
        """
        ...

    @values.setter
    def values(self, value: List[str]):
        ...


@pulumi.input_type
class GetLocalGatewayVirtualInterfaceGroupFilterArgs:
    def __init__(__self__, *,
                 name: str,
                 values: List[str]):
        """
        :param str name: Name of the filter.
        :param List[str] values: List of one or more values for the filter.
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "values", values)

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        Name of the filter.
        """
        ...

    @name.setter
    def name(self, value: str):
        ...

    @property
    @pulumi.getter
    def values(self) -> List[str]:
        """
        List of one or more values for the filter.
        """
        ...

    @values.setter
    def values(self, value: List[str]):
        ...


@pulumi.input_type
class GetLocalGatewayVirtualInterfaceGroupsFilterArgs:
    def __init__(__self__, *,
                 name: str,
                 values: List[str]):
        """
        :param str name: Name of the filter.
        :param List[str] values: List of one or more values for the filter.
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "values", values)

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        Name of the filter.
        """
        ...

    @name.setter
    def name(self, value: str):
        ...

    @property
    @pulumi.getter
    def values(self) -> List[str]:
        """
        List of one or more values for the filter.
        """
        ...

    @values.setter
    def values(self, value: List[str]):
        ...


@pulumi.input_type
class GetLocalGatewaysFilterArgs:
    def __init__(__self__, *,
                 name: str,
                 values: List[str]):
        """
        :param str name: The name of the field to filter by, as defined by
               [the underlying AWS API](https://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_DescribeLocalGateways.html).
        :param List[str] values: Set of values that are accepted for the given field.
               A Local Gateway will be selected if any one of the given values matches.
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "values", values)

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        The name of the field to filter by, as defined by
        [the underlying AWS API](https://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_DescribeLocalGateways.html).
        """
        ...

    @name.setter
    def name(self, value: str):
        ...

    @property
    @pulumi.getter
    def values(self) -> List[str]:
        """
        Set of values that are accepted for the given field.
        A Local Gateway will be selected if any one of the given values matches.
        """
        ...

    @values.setter
    def values(self, value: List[str]):
        ...


@pulumi.input_type
class GetNatGatewayFilterArgs:
    def __init__(__self__, *,
                 name: str,
                 values: List[str]):
        """
        :param str name: The name of the field to filter by, as defined by
               [the underlying AWS API](https://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_DescribeNatGateways.html).
        :param List[str] values: Set of values that are accepted for the given field.
               An Nat Gateway will be selected if any one of the given values matches.
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "values", values)

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        The name of the field to filter by, as defined by
        [the underlying AWS API](https://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_DescribeNatGateways.html).
        """
        ...

    @name.setter
    def name(self, value: str):
        ...

    @property
    @pulumi.getter
    def values(self) -> List[str]:
        """
        Set of values that are accepted for the given field.
        An Nat Gateway will be selected if any one of the given values matches.
        """
        ...

    @values.setter
    def values(self, value: List[str]):
        ...


@pulumi.input_type
class GetNetworkAclsFilterArgs:
    def __init__(__self__, *,
                 name: str,
                 values: List[str]):
        """
        :param str name: The name of the field to filter by, as defined by
               [the underlying AWS API](https://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_DescribeNetworkAcls.html).
        :param List[str] values: Set of values that are accepted for the given field.
               A VPC will be selected if any one of the given values matches.
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "values", values)

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        The name of the field to filter by, as defined by
        [the underlying AWS API](https://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_DescribeNetworkAcls.html).
        """
        ...

    @name.setter
    def name(self, value: str):
        ...

    @property
    @pulumi.getter
    def values(self) -> List[str]:
        """
        Set of values that are accepted for the given field.
        A VPC will be selected if any one of the given values matches.
        """
        ...

    @values.setter
    def values(self, value: List[str]):
        ...


@pulumi.input_type
class GetNetworkInterfaceFilterArgs:
    def __init__(__self__, *,
                 name: str,
                 values: List[str]):
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "values", values)

    @property
    @pulumi.getter
    def name(self) -> str:
        ...

    @name.setter
    def name(self, value: str):
        ...

    @property
    @pulumi.getter
    def values(self) -> List[str]:
        ...

    @values.setter
    def values(self, value: List[str]):
        ...


@pulumi.input_type
class GetNetworkInterfacesFilterArgs:
    def __init__(__self__, *,
                 name: str,
                 values: List[str]):
        """
        :param str name: The name of the field to filter by, as defined by
               [the underlying AWS API](https://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_DescribeNetworkInterfaces.html).
        :param List[str] values: Set of values that are accepted for the given field.
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "values", values)

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        The name of the field to filter by, as defined by
        [the underlying AWS API](https://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_DescribeNetworkInterfaces.html).
        """
        ...

    @name.setter
    def name(self, value: str):
        ...

    @property
    @pulumi.getter
    def values(self) -> List[str]:
        """
        Set of values that are accepted for the given field.
        """
        ...

    @values.setter
    def values(self, value: List[str]):
        ...


@pulumi.input_type
class GetRouteTableFilterArgs:
    def __init__(__self__, *,
                 name: str,
                 values: List[str]):
        """
        :param str name: The name of the field to filter by, as defined by
               [the underlying AWS API](http://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_DescribeRouteTables.html).
        :param List[str] values: Set of values that are accepted for the given field.
               A Route Table will be selected if any one of the given values matches.
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "values", values)

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        The name of the field to filter by, as defined by
        [the underlying AWS API](http://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_DescribeRouteTables.html).
        """
        ...

    @name.setter
    def name(self, value: str):
        ...

    @property
    @pulumi.getter
    def values(self) -> List[str]:
        """
        Set of values that are accepted for the given field.
        A Route Table will be selected if any one of the given values matches.
        """
        ...

    @values.setter
    def values(self, value: List[str]):
        ...


@pulumi.input_type
class GetRouteTablesFilterArgs:
    def __init__(__self__, *,
                 name: str,
                 values: List[str]):
        """
        :param str name: The name of the field to filter by, as defined by
               [the underlying AWS API](http://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_DescribeRouteTables.html).
        :param List[str] values: Set of values that are accepted for the given field.
               A Route Table will be selected if any one of the given values matches.
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "values", values)

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        The name of the field to filter by, as defined by
        [the underlying AWS API](http://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_DescribeRouteTables.html).
        """
        ...

    @name.setter
    def name(self, value: str):
        ...

    @property
    @pulumi.getter
    def values(self) -> List[str]:
        """
        Set of values that are accepted for the given field.
        A Route Table will be selected if any one of the given values matches.
        """
        ...

    @values.setter
    def values(self, value: List[str]):
        ...


@pulumi.input_type
class GetSecurityGroupFilterArgs:
    def __init__(__self__, *,
                 name: str,
                 values: List[str]):
        """
        :param str name: The name of the field to filter by, as defined by
               [the underlying AWS API](http://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_DescribeSecurityGroups.html).
        :param List[str] values: Set of values that are accepted for the given field.
               A Security Group will be selected if any one of the given values matches.
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "values", values)

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        The name of the field to filter by, as defined by
        [the underlying AWS API](http://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_DescribeSecurityGroups.html).
        """
        ...

    @name.setter
    def name(self, value: str):
        ...

    @property
    @pulumi.getter
    def values(self) -> List[str]:
        """
        Set of values that are accepted for the given field.
        A Security Group will be selected if any one of the given values matches.
        """
        ...

    @values.setter
    def values(self, value: List[str]):
        ...


@pulumi.input_type
class GetSecurityGroupsFilterArgs:
    def __init__(__self__, *,
                 name: str,
                 values: List[str]):
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "values", values)

    @property
    @pulumi.getter
    def name(self) -> str:
        ...

    @name.setter
    def name(self, value: str):
        ...

    @property
    @pulumi.getter
    def values(self) -> List[str]:
        ...

    @values.setter
    def values(self, value: List[str]):
        ...


@pulumi.input_type
class GetSubnetFilterArgs:
    def __init__(__self__, *,
                 name: str,
                 values: List[str]):
        """
        :param str name: The name of the field to filter by, as defined by
               [the underlying AWS API](http://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_DescribeSubnets.html).
               For example, if matching against tag `Name`, use:
        :param List[str] values: Set of values that are accepted for the given field.
               A subnet will be selected if any one of the given values matches.
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "values", values)

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        The name of the field to filter by, as defined by
        [the underlying AWS API](http://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_DescribeSubnets.html).
        For example, if matching against tag `Name`, use:
        """
        ...

    @name.setter
    def name(self, value: str):
        ...

    @property
    @pulumi.getter
    def values(self) -> List[str]:
        """
        Set of values that are accepted for the given field.
        A subnet will be selected if any one of the given values matches.
        """
        ...

    @values.setter
    def values(self, value: List[str]):
        ...


@pulumi.input_type
class GetSubnetIdsFilterArgs:
    def __init__(__self__, *,
                 name: str,
                 values: List[str]):
        """
        :param str name: The name of the field to filter by, as defined by
               [the underlying AWS API](http://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_DescribeSubnets.html).
               For example, if matching against tag `Name`, use:
        :param List[str] values: Set of values that are accepted for the given field.
               Subnet IDs will be selected if any one of the given values match.
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "values", values)

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        The name of the field to filter by, as defined by
        [the underlying AWS API](http://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_DescribeSubnets.html).
        For example, if matching against tag `Name`, use:
        """
        ...

    @name.setter
    def name(self, value: str):
        ...

    @property
    @pulumi.getter
    def values(self) -> List[str]:
        """
        Set of values that are accepted for the given field.
        Subnet IDs will be selected if any one of the given values match.
        """
        ...

    @values.setter
    def values(self, value: List[str]):
        ...


@pulumi.input_type
class GetVpcDhcpOptionsFilterArgs:
    def __init__(__self__, *,
                 name: str,
                 values: List[str]):
        """
        :param str name: The name of the field to filter.
        :param List[str] values: Set of values for filtering.
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "values", values)

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        The name of the field to filter.
        """
        ...

    @name.setter
    def name(self, value: str):
        ...

    @property
    @pulumi.getter
    def values(self) -> List[str]:
        """
        Set of values for filtering.
        """
        ...

    @values.setter
    def values(self, value: List[str]):
        ...


@pulumi.input_type
class GetVpcEndpointFilterArgs:
    def __init__(__self__, *,
                 name: str,
                 values: List[str]):
        """
        :param str name: The name of the field to filter by, as defined by
               [the underlying AWS API](https://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_DescribeVpcEndpoints.html).
        :param List[str] values: Set of values that are accepted for the given field.
               A VPC Endpoint will be selected if any one of the given values matches.
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "values", values)

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        The name of the field to filter by, as defined by
        [the underlying AWS API](https://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_DescribeVpcEndpoints.html).
        """
        ...

    @name.setter
    def name(self, value: str):
        ...

    @property
    @pulumi.getter
    def values(self) -> List[str]:
        """
        Set of values that are accepted for the given field.
        A VPC Endpoint will be selected if any one of the given values matches.
        """
        ...

    @values.setter
    def values(self, value: List[str]):
        ...


@pulumi.input_type
class GetVpcEndpointServiceFilterArgs:
    def __init__(__self__, *,
                 name: str,
                 values: List[str]):
        """
        :param str name: The name of the filter field. Valid values can be found in the [EC2 DescribeVpcEndpointServices API Reference](https://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_DescribeVpcEndpointServices.html).
        :param List[str] values: Set of values that are accepted for the given filter field. Results will be selected if any given value matches.
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "values", values)

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        The name of the filter field. Valid values can be found in the [EC2 DescribeVpcEndpointServices API Reference](https://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_DescribeVpcEndpointServices.html).
        """
        ...

    @name.setter
    def name(self, value: str):
        ...

    @property
    @pulumi.getter
    def values(self) -> List[str]:
        """
        Set of values that are accepted for the given filter field. Results will be selected if any given value matches.
        """
        ...

    @values.setter
    def values(self, value: List[str]):
        ...


@pulumi.input_type
class GetVpcFilterArgs:
    def __init__(__self__, *,
                 name: str,
                 values: List[str]):
        """
        :param str name: The name of the field to filter by, as defined by
               [the underlying AWS API](http://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_DescribeVpcs.html).
        :param List[str] values: Set of values that are accepted for the given field.
               A VPC will be selected if any one of the given values matches.
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "values", values)

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        The name of the field to filter by, as defined by
        [the underlying AWS API](http://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_DescribeVpcs.html).
        """
        ...

    @name.setter
    def name(self, value: str):
        ...

    @property
    @pulumi.getter
    def values(self) -> List[str]:
        """
        Set of values that are accepted for the given field.
        A VPC will be selected if any one of the given values matches.
        """
        ...

    @values.setter
    def values(self, value: List[str]):
        ...


@pulumi.input_type
class GetVpcPeeringConnectionFilterArgs:
    def __init__(__self__, *,
                 name: str,
                 values: List[str]):
        """
        :param str name: The name of the field to filter by, as defined by
               [the underlying AWS API](http://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_DescribeVpcPeeringConnections.html).
        :param List[str] values: Set of values that are accepted for the given field.
               A VPC Peering Connection will be selected if any one of the given values matches.
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "values", values)

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        The name of the field to filter by, as defined by
        [the underlying AWS API](http://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_DescribeVpcPeeringConnections.html).
        """
        ...

    @name.setter
    def name(self, value: str):
        ...

    @property
    @pulumi.getter
    def values(self) -> List[str]:
        """
        Set of values that are accepted for the given field.
        A VPC Peering Connection will be selected if any one of the given values matches.
        """
        ...

    @values.setter
    def values(self, value: List[str]):
        ...


@pulumi.input_type
class GetVpcsFilterArgs:
    def __init__(__self__, *,
                 name: str,
                 values: List[str]):
        """
        :param str name: The name of the field to filter by, as defined by
               [the underlying AWS API](http://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_DescribeVpcs.html).
        :param List[str] values: Set of values that are accepted for the given field.
               A VPC will be selected if any one of the given values matches.
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "values", values)

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        The name of the field to filter by, as defined by
        [the underlying AWS API](http://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_DescribeVpcs.html).
        """
        ...

    @name.setter
    def name(self, value: str):
        ...

    @property
    @pulumi.getter
    def values(self) -> List[str]:
        """
        Set of values that are accepted for the given field.
        A VPC will be selected if any one of the given values matches.
        """
        ...

    @values.setter
    def values(self, value: List[str]):
        ...


@pulumi.input_type
class GetVpnGatewayFilterArgs:
    def __init__(__self__, *,
                 name: str,
                 values: List[str]):
        """
        :param str name: The name of the field to filter by, as defined by
               [the underlying AWS API](http://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_DescribeVpnGateways.html).
        :param List[str] values: Set of values that are accepted for the given field.
               A VPN Gateway will be selected if any one of the given values matches.
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "values", values)

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        The name of the field to filter by, as defined by
        [the underlying AWS API](http://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_DescribeVpnGateways.html).
        """
        ...

    @name.setter
    def name(self, value: str):
        ...

    @property
    @pulumi.getter
    def values(self) -> List[str]:
        """
        Set of values that are accepted for the given field.
        A VPN Gateway will be selected if any one of the given values matches.
        """
        ...

    @values.setter
    def values(self, value: List[str]):
        ...


